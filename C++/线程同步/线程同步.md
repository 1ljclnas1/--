# 线程同步

对于线程同步的理解：

从狭义上，从资源的角度看，是对临界区的有序访问

广义上看，是为了让多个线程在并发执行时可以保证执行的正确性，得出正确的结果。

那么从微观上看，就是保证在对某些临界区的访问是线性的，从而保证宏观上的并发正确性。

总结就是，对临界区使用防同步机制，从而达到线程同步。

对于防同步呢分为**时间上的防同步**和**空间上的防同步**和**事后防同步**

## 时间上的

### 1. 原子操作

### 2. 加锁（自旋锁与阻塞锁）

### 3. 临时禁用伪并发

1. 禁用中断

2. 禁用软中断

3. 禁用抢占

## 空间上的

### 1. 数据分割

对于多核，可以同时，但是不访问相同的数据，比如在LoonArch上的SPMV中我就是这么实现的，矩阵分块多核同时计算。

### 2. 数据复制

RCU,只适用于指针访问的动态数据。读者复制指针，然后就可以随意读取数据了，所有读者共同读一份数据。写者复制数据，然后就可以随意修改复制后的数据了，引文这份数据是私有的。不过修改完之后要修改指针指向最新的数据，修改指针的这个操作需要是原子的。对于读者来说，它是复制完指针之后用自己的私有指针来访问数据的，所以它访问的要么是之前的数据，要么是修改之后的数据，不会出现不一致的数据。

## 事后防同步

不去积极预防并发，而是假设不存在并发，直接访问数据。访问完之后再检查刚才是否有并发发生，如果有就重来一遍，一直重试，直到没有并发发生为止。这就是内核里面的序列锁seqlock
