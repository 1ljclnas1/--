# 面试题

## 1. 左值引用与右值引用的区别？右值引用的意义？

区别：

左值引用，是对左值的引用。避免对象的拷贝，比如函数传参，函数返回值

右值引用，是对右值的引用。实现移动语义，实现完美转发。

区分左值右值，可以在等号左边，可以取地址并且是具名的。比如变量名，返回左值引用的函数调用，前置自增自减、

右值只能在等号右边，不能取地址，不具名。

通常字面量是一个右值，除了字符串字面量。

## 左值引用

让C++编程一定程度上脱离了危险的指针。

举例：在函数传参的时候，函数返回

非常量左值的引用对象必须是一个左值，而常量左值的引用对象可以是一个右值。举例，复制构造函数和复制赋值运算符函数。通常情况下实现的两个函数的形参都是一个常量左值引用。虽然常量左值引用可以绑定到右值，但是也存在一个缺陷：常量性。一旦使用的常量左值引用，那么就无法在函数内修改该对象的内容（强制类型转换除外）。所以需要另外一个特性来完成这项工作，就是右值引用

## 右值引用

右值引用顾名思义，是一种引用右值且只能引用右值的方法。添加&&。

右值引用的特点就是可以延长右值的生命周期。

比如

```cpp
#include <iostream>

class X{
    X(){ cout << "X ctor" << endl; }
    X(const X&x) { cout << "X copy ctor" <<endl; }
    ~X() { cout << "X ctor" << endl; }
    void show() { cout << "show X" <<endl; }
};

X make_X(){
    X x1;
    return x1;
}

int main(){
    X &&x2=make_X();
    x2.show();
}
```

这里使用了右值引用，那么可以减少X &&x2=make_X();这条语句的一次复制构造函数的调用。

右值引用的最终目标是减少对象的复制，提升程序的性能。

## 右值的性能优化空间

很多情况下，右值存储在临时对象中，当右值被使用后程序会马上销毁对象并释放内存。这可能会引发一个性能问题。

```cpp
#include <iostream>
using namespace std;
class BigMemoryPool{
    public:
        static const int PoolSize - 4096;
        BigMemoryPool() : pool_(new char[PoolSize]){}
        ~BigMemoryPool(){
            if(pool_){
                delete[] pool_;
            }
        }
        BigMemoryPool(const BigMemoryPool& other) : pool_(new char[PoolSize){
            cout << "copy big memory" <<endl;
            memcpy(pool_, other.pool, PoolSize);
        }
    private:
        char *pool_;
};


BigMemoryPool get_pool(const BigMemoryPool& pool){
    return pool;
}
BigMemoryPool make_pool(){
    BigMemoryPool pool;
    return get_pool(pool);
}

int main(){
    BigMemoryPool my_pool = make_pool();
}
```

以上会调用三次复制构造函数

1. get_pool返回的临时对象调用复制构造函数复制了pool对象。

2. make_pool返回的BigMemoryPool临时对象调用了复制构造函数复制了get_pool返回的临时对象。

3. main函数中的my_pool调用复制构造函数复制了make_pool返回的临时对象。

## 移动语义

上面代码的2，3是主要影响性能的关键。如果可以将临时对象的内存直接转移到my_pool中就好了。可以使用移动语义。

```cpp
class BigMemoryPool{
    public:
        static const int PoolSize - 4096;
        BigMemoryPool() : pool_(new char[PoolSize]){}
        ~BigMemoryPool(){
            if(pool_){
                delete[] pool_;
            }
        }
        BigMemoryPool(BigMemoryPool&& other) : pool_(new char[PoolSize){
            cout << "move big memory pool" <<endl;
            pool_ = other.pool_;
            other.pool_ = nullptr;
        }
        BigMemoryPool(const BigMemoryPool& other) : pool_(new char[PoolSize){
            cout << "copy big memory" <<endl;
            memcpy(pool_, other.pool, PoolSize);
        }
    private:
        char *pool_;
};
```

增加一个移动构造函数。移动构造函数的形参是一个右值引用，其核心思想是通过转移实参对象的数据以达到构造的目的。

对于右值编译器会优先选择移动构造函数。当不存在是才选择复制构造函数。

移动赋值运算符也可以完成

```cpp
class BigMemoryPool{
    public:
        ...
        BigMemoryPool& operator=(BigMemoryPool&& other){
            cout << "move(operator=) big memory pool" <<endl;
            if(pool_) delete[] pool_;
            pool_ = other.pool_;
            other.pool_ = nullptr;
            return *this;
        }
    private:
        char *pool_;
};
```

移动语义的使用是有风险的，如果出现异常没那么对象将只转换一半，所以一般使用noexcept限制这个函数，如果出现异常就调用std::terminate终止程序执行。

## 值类别

表达式被分为泛左值和右值，其中泛左值进一步被分为左值和将亡值，右值进一步被分为将亡值和纯右值。

1. 所谓泛左值是指一个通过评估能够确定对象、位域或函数的标识的表达式。简单来说，他确定了对象或者函数的标识。（具名对象）

2. 纯右值是指一个通过评估能够用于初始化对象和位域，或者能够计算运算符操作数的值的表达式。

3. 将亡值属于泛左值的一种，它表示资源可以被重用的对象和位域，通常这是因为它们接近生命周期的末尾，另外也可能是经过右值引用的转换产生的。

值类别都是表达式的属性，所以常说的左值右值实际上指的是表达式。

左值就是C++98的左值，纯右值就是C++98的右值。

将亡值：

从本质上说产生将亡值的途径有两种：

1. 使用类型转换将泛左值转换为该类型的右值引用。static_cast<BigMemoryPool&&>(my_pool)。

2. 在C++17中引入，临时量实质化，指的是纯右值转换到临时对象的过程。每当纯右值出现在一个需要泛左值的地方时，临时量实质化都会发生，也就是说都会创建一个临时对象并且使用纯右值对其进行初始化，而这里的临时对象就是一个将亡值。
   
   ```cpp
   struct X{
       int a;
   };
   int main(){
       int b = X().a;
   }
   ```

X()是一个纯右值，访问其成员变量a却需要一个泛左值，所以这里会发生一次临时量实质化，将X()转换为将亡值，最后再访问其成员变量a。在C++17标准之前临时变量是纯右值，只有转换为右值引用的类型才是将亡值。

## 将左值转换为右值

右值引用想绑定到左值，就需要将左值转换为将亡值，move或static_cast。

在函数传参的时候，无论一个函数的实参是左值还是右值，形参都是左值，尽管这个形参看上去是一个右值引用。这个时候可以使用移动语义对形参进行处理以提高性能。（调用移动构造函数或移动赋值运算符函数，避免复制）

## 万能引用和引用折叠

T&& auto&&

正常右值引用只能引用右值，而如果是模板类型或auto类型则没有这个限制。

其实其因为，在这里发生了类型推导。究其原因是因为C++11中添加了一套引用叠加推导的规则---引用折叠。

类模板型如果是左值引用，那么不管T实际类型是什么都推导出R&

类模板型是右值引用，那么除非实际类型是引用，否则推导出的都是右值引用。

## 完美转发

万能引用的典型用途就是完美转发。避免产生多余的复制。同样注意形参为左值的问题。这里可以使用std::forward函数模板

```cpp
template <class T>
void perfect_forwarding(T &&t){
    show_type(std::forward<T>(t));
}
```

注意与move的区别，move一定会将实参转换为右值引用，并且不需要模板实参，它是被推导出来的。forward则会根据左值右值的情况进行转发，使用的时候需要指定模板实参。

# 2. malloc是如何分配内存的

malloc分配的是虚拟内存，

进程虚拟内存空间分布：从低地址往高走，代码段（二进制可执行代码），已初始化数据段（静态常量），未初始化数据段（未初始化的静态变量），堆段（从低往高扩展，动态分配），文件映射段（动态库，共享内存等），栈段（由高往低地址，局部变量，函数调用上下文等），内核空间（所有进程共享）。

可执行文件装载时，内核就为数据段分配好虚拟地址和物理页面，并建立好二者的映射关系。

只有在使用的时候才会具体分配物理内存，调用malloc不会分配真实的物理内存。

怎么分配物理内存？缺页异常

如何分配？内存小于128K，通过系统调用*brk*从堆段分配，大于等于128K，通过*mmap*系统调用从文件映射段分配。

malloc是不是系统调用名？不是，是库函数。

优先从内存池中分配， 作用：减少系统调用的次数，减少缺页异常的次数。缺点，增加内存碎片。

# 3. free怎么知道释放多少内存

释放内存后，内存还在么？

通过brk分配的，free后回收到内存池中，

mmap分配的，归还到操作系统。

会多分配16字节用来记录元信息，释放的时候，指针向左移动十六位然后根据元信息释放空间。

# 4. 写文件时进程宕机，数据会丢失么？

写文件的机制：

stdio库：stdio缓冲区（用户空间缓冲区），可以通过setbuf自定义缓冲区，

fflush（内部调用write，把用户缓冲区刷到内核缓冲区page cache)。

page cache减少磁盘io次数。缺点：无法优化page cache的策略，这也是为什么数据库要维护一个page cache管理。

fsync（指定fd）, fdatasync把内核缓冲区刷到磁盘。

sync把所有打开文件全部刷盘。

两种磁盘io方式：缓存文件io，文件io（用户缓冲区直接到磁盘中没有page cache）。

写文件，还没调用fflush（write），数据百分百丢失了，因为数据在用户空间，

调用了fflush（write），数据不会丢失，在内核缓冲区

如果系统关闭前，调用直接文件io且已经调用了write，数据不会丢失。使用缓存文件io如果系统关闭了那么数据也丢失了。

大文件使用直接文件io，小数据使用缓存文件io。

# 5. 什么是MTU、MSS以及为什么要有MSS？

# 6. 智能指针种类以及使用场景

悬垂指针、野指针、踩内存，内存泄漏，重复释放

shared_ptr：内部存在一个引用计数，为零的时候析构，按照对象来进行管理

weak_ptr：解决shared_ptr的循环引用问题。

unique_ptr：独享所有权

# 7. 谈谈C++多态

C++的四种多态：运行时多态，编译时多态，重载，强制多态

## 运行时多态

通过基类的指针或者引用来使用派生类

## 参数多态（编译时多态）

对任何类型执行相同代码。通过模板来实现

## 重载多态

允许函数拥有相同的函数名而对不同的类型的数据执行不同的动作

## 强制多态（类型转换）

将一个对象或者类型强制转换成另外一种对象类型。

# 8. C++11的新特性有哪些？回答10个

1. move semantics - 移动语意学,增加右值引用等使资源移动优先于复制。
2. lambda expressions - Lambda表达式,使编写匿名函数更简洁。
3. smart pointers - 智能指针,如shared_ptr等,更安全的指针管理。
4. threads support - 线程库,原生线程支持。
5. std::async - 异步函数调用,基于future/promise实现异步编程。
6. range-based for loop - 基于范围的for循环,简化代码。
7. auto type inference - 自动类型推断,减少冗余代码。
8. uniform initialization - 统一初始化语法{}替代(),避免隐患。
9. chrono - 时间库chrono,更方便处理时间。
10. 函数返回类型后置
11. 指针字面量nullptr
12. 线程局部存储
13. 常量表达式constexpr
14. 可变参数模板
15. 委托构造
16. 强枚举类型
17. SFINAE

# 9. 讲一下孤儿、僵尸进程

**僵尸进程**：一个进程使用fork创建子进程,如果子进程退出,而父进程并没有调用wait或waitpid获取子进程状态信息,那么子进程的进程描述符仍然保存在系统中。内核只释放了该进程打开的文件，占用的内存等。这种进程称之为僵死进程。

- 僵死进程仍旧占用一个进程号,不能被其它进程使用。
- 通过ps命令查看进程状态为Z(zombie)则为僵死进程。
- 大量的僵死进程将影响系统的运行（没有进程号了）

**孤儿进程**：一个父进程退出，而它的子进程还在运行，这些叫做孤儿进程。

孤儿进程将会被init进程收养，由init完成对他们的状态收集。

**危害**：

大量的僵尸进程会导致系统不能产生新的进程

孤儿进程会被init收养，不会有什么危害。

**解决僵尸进程：**

- 父进程通过wait或waitpid等待子进程结束，但是这样就不能并发了，那创建子进程的意义就没有了，因此不是一个好的解决方案。

- 通过信号机制：子进程退出的时候向父进程发送SIGCHILD信号，父进程在处理SIGCHILD的处理函数中调用wait获取子进程的信息。

- fork两次：将进程转变为孤儿进程父进程fork后调用wait回收，子进程再fork一个孙子进程，然后子进程exit这样孙子就是个孤儿进程，这时孙子失去了它的父进程，被init收养。

- kill父进程：本质上来说僵死的进程不是根源，产生大量僵死的是父进程，kill这个父进程就好了。

# 10. 讲一下多进程编程

# 11.讲一下多线程

由于进程的切换开销太大，因此有了多线程，提高执行效率。

C++11有标准的线程库thread，还提供了几个线程同步类mutex-lock_guard实现互斥锁，condition_variable实现条件变量，atomic提供原子操作。还提供了两个异步编程用的future/promise对象配合async实现异步调用。

对于多线程来说管理对象的生命周期是很重要的，由于C++要求程序员自己管理对象的生命周期，因此再多线程的环境下非常困难。当一个对象可以被多个线程看到的时候，就会出现各种竞态条件。比如析构的时候怎么知道是否有其他线程正在执行它的成员函数，如何保证执行成员函数的时候，对象不被另一个线程析构等等。因此在多线程编程的时候要注意对象的线程安全。而像标准库里的容器大多不是线程安全的，通常需要外部加锁来保证线程安全。比如互斥锁。

对象的创建是比较简单的只要不泄露this指针即可。

对象的销毁是很难的，单线程最多就是空悬指针或野指针问题，而多线程下即使用mutex也不能保证线程安全，因为析构函数中**mutex成员也会被销毁**。

shared_ptr：

- 控制对象额度生命周期，只要有一个还在用，就不会析构。

- weak_ptr：不控制生命周期，但是知道对象是否还活着，如果活着可以提升为shared_ptr

- shared_ptr/weak_ptr是原子操作，没有用锁。

- shared_ptr/weak_ptr的线程安全级别和string和STL容器一样。

shared_ptr本身不是100%的线程安全。它的引用计数是安全无锁的，但对象的读写则不是，多个线程读写同一个shared_ptr对象需要加锁。析构属于写操作。

shared_pre是现成的RAII handle，为了避免循环引用一般是owner持有child的shared_ptr，child持有owner的weak_ptr。

# 12. ip数据包分片

如果数据包大小超过了下一层的如MTU，路由器需要进行分片

路由器把过大的数据报切割成若干碎片，并在IP头部写入分片信息，每片都作为独立的数据报通过路由传输，有不同次序到达的可能。目标主机按照分片信息和标志位重新组装，所有数据报分片在一定时间内必须全部到达，否则丢弃

# 13. mss和mtu区别，如何确定

1. MTU - Maximum Transmission Unit,最大传输单元。
- 指链路层单次能传输数据报文的最大大小。如以太网的MTU是1500字节。
- 不同链路层的MTU不一样,需要参考标准或设备手册。
- IP层的数据报若超过MTU需要分片。
2. MSS - Maximum Segment Size,最大分节大小。
- 指TCP建立连接时双方协商的单个TCP段能传输的最大大小。
- MSS = MTU - IP头部 - TCP头部,对IPv4是MTU-40,按字节计算。
- TCP会根据MSS来适当分片报文避免IP分片。

MTU由链路层决定，而MSS可以在连接时协商。

# 14. 空对象指针为什么能调用函数

可以调用函数，不能调用函数内访问了成员变量的函数。

成员函数有一个隐含指针this，调用时自动传递

即使this指针是nullptr也可以被传递。

对于虚函数，Segmentation fault，对于虚表指针也是通过隐式指针this使用的，因此会报错。

# 15. shared_ptr线程安全么？

shared_ptr：

- 控制对象额度生命周期，只要有一个还在用，就不会析构。

- weak_ptr：不控制生命周期，但是知道对象是否还活着，如果活着可以提升为shared_ptr

- shared_ptr/weak_ptr是原子操作，没有用锁。

- shared_ptr/weak_ptr的线程安全级别和string和STL容器一样。

shared_ptr本身不是100%的线程安全。它的引用计数是安全无锁的，但对象的读写则不是，多个线程读写同一个shared_ptr对象需要加锁。析构属于写操作。

shared_pre是现成的RAII handle，为了避免循环引用一般是owner持有child的shared_ptr，child持有owner的weak_ptr。

# 16. push_back左值和右值的区别。

对于vector，list和map等都支持移动构造函数和移动赋值运算符函数，应该运用右值，来避免无谓的复制行为。

对于左值会调用复制构造函数将元素复制到容器中。

而如果元素类型没有提供移动构造函数或移动赋值运算符函数，那么会退化为复制构造函数。对于基础类型直接进行拷贝，对于复杂类对象使用右值会提高效率。

向make_pair和make_tuple和make_shared等也都使用了完美转发以提高效率。

# 17. move的底层实现，内存复制

C++11中引入的移动语义(move)在底层通过指针传递和交换实现,主要机制是:

1. 对象在内存中是连续分布的,可以用起始指针代表。
2. 移动构造函数参数通常使用右值引用类型。
3. 通过传递对象指针,直接交换目标对象与参数对象的指针。
4. 这样目标对象指针指向参数的内存区域,参数对象资源被覆盖。
5. 没有内存块的实际复制,只是指针和资源的交换。
6. 如果有必要,编译器可能选择进行内存复制。
7. 但语义上仍为指针交换的移动,而非复制。

所以移动语义通过指针交换让目标对象指向参数的内存,避免复制,极大提升了效率。

这也使得返回值优化(RVO)和右值传参非常高效。

# 18. 完美转发原理

需要先说一下万能引用，完美转发是万能引用的一个用途。

C++11的万能引用，由于常量左值引用虽然既可以引用左值，又可以引用右值，但是其有常量性的限制，而万能引用实际上是利用引用折叠的推导规则来实现万能引用，引用折叠：当模板类型是T&&的时候，除非是左值引用不然都推导为右值引用，当模板类型是T&的时候，全部推导为左值引用。简单理解只要涉及到左值引用就被推导为左值引用，不然是右值引用。

使用万能引用来保证转发的时候减少对象的复制操作。

在C++11中提供了一个std::forward函数模板可以根据参数的属性进行转发，与move不同的是move总会转为一个右值引用，而forward根据左值和右值的实际情况进行转发，在使用的时候需要指定实参。

# 19. 空类有什么函数

对于空类(没有任何成员变量)在C++中,编译器会自动生成以下的成员函数:

1. 默认构造函数和析构函数

空类默认有一个公有的默认构造函数和析构函数。构造函数和析构函数内部都不包含任何操作。

2. 默认拷贝构造函数和拷贝赋值操作符

空类会有一个默认的公有拷贝构造函数,用于实例之间拷贝构造。还有默认的拷贝赋值操作符重载。

3. 移动构造函数和移动赋值操作符

C++11增加了默认的移动构造函数和移动赋值操作符。

4. 比较运算符

编译器会自动生成相等运算符和不等运算符的重载函数。

此外,空类的默认访问控制符是private。

所以空类主要包含一些默认生成的构造/析构/赋值/比较函数,以及私有访问权限。不包含其他普通类可有的成员函数。

# 20. explicit用在哪儿

1. 构造函数，避免单参数的隐式类型转换。

2. 类型转换操作符，避免隐式类型转换，限定只能显式类型转换。

# 21. 成员变量初始化顺序

1. 基类的静态变量或全局变量

2. 派生类的静态变量或全局变量

3. 基类的成员变量

4. 派生类的成员变量

成员变量在使用初始化列表的时候，与构造函数的初始化成员列表顺序无关，只与定义的顺序有关

如果不适用初始化成员列表，在构造函数内初始化，则与在构造函数内的顺序一致。

类中的const成员变量必须在构造函数初始化列表中初始化

**类中static成员变量必须在类外初始化。需要注意C++11引入inline可以让static inline的成员变量在类内初始化。**

# 22. C++四种类型转换

1. static_cast: 没有类型时检查来保证转换的安全性。
   
   - 用于类层次结构中基类和派生类之间指针或引用的转换
   
   - 用于基本数据类型之间的转换
   
   - 把空指针转换成目标类型的空指针
   
   - 把任何类型的表达式转换成void类型

2. const_cast：
   
   - <>里面的必须是引用或者指针
   
   - 主要用于添加或一处对象的常量性
   
   - 常量转换不能用于修改变量实际所指向的值，否则会发生未定义的行为。

3. reinterpret_cast：
   
   - 用于在不同类型之间进行位模式转换，通常用于处理底层的指针或引用类型
   
   - 可以将任意指针类型转换为另一个指针类型，也可以将任意整数类型转换为指针类型
   
   - 重新解释转换不会进行任何类型检查。

4. dynamic_cast：
   
   - 用于类层次结构中，允许将基类指针或引用转换为派生类指针或引用，或将派生类指针转换为基类指针或引用。
   
   - 在运行时进行类型检查，如果是不安全的则返回空指针或者引发std::bad_cast异常（如果是引用转换）。
   
   - 只能用于具有虚函数的类层次结构。因此动态转换主要用于多态类型之间的安全转换。

# 23. vector实现原理，如何优化使用

vector是一个动态数组，他维护了一段连续的动态内存空间，然后有三个成员变量。保存开始位置、当前已使用位置、申请的动态内存的最后一个位置的下一个位置，每当用完的时候，按照原有空间大小双倍重新申请，并把原来的元素都拷贝过去。

1. 在不确定的情况下使用at而不是[]，因为at可以检查是否越界

2. 可以使用swap迅速释放内存空间，resize和clear会对已保存的元素进行析构。

3. 传入右值，由于vector、set、map等都实现了完美转发，因此push_back的时候使用右值可以使用元素的移动语义，避免不必要的拷贝，前提是元素具有移动构造或移动赋值运算符函数。

# 24. set实现原理

首先底层是红黑树，由于set被定义为集合，涉及交，并，差等操作，有大量的比较，因此采用红黑树比较合适。

# 25. 进程间的通信方式

1. 管道：具有亲缘关系进程间的通信，允许一个进程与另一个有共同祖先的进程通信

2. 命名管道：克服了管道没有名字的限制，还允许无亲缘关系的进程之间通信。在文件系统中有对应的文件名，通过mkfifo创建。

3. 信号：用于通知接受进程有某种事件发生，除了用于进程通信，还可以发送信号给进程本身。

4. 消息队列：消息的链接表，包括Posix消息队列，system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走消息。克服了信号承载信息少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。

5. 共享内存：使多个进程可以访问同一块内存。与信号量结合达到同步及互斥

6. 信号量：进程间或一个进程的多个线程间的同步手段（linux下仅线程间）

7. 套接字：更为一般的进程间通信，可用于不同机器间的进程通信。

# 26. 线程间的通信方式

1. message passing
   
   - 采用全局变量的方式，需要配合同步机制
   
   - promise、future语法。promise<T>对象通过promise.get_future()函数和future<T>对象联系起来，promise对象通过set_value设置值，而future对象通过get获取值。这在两个线程内也可以执行。在get没有获取值之前该线程被阻塞。
   
   - packaged_task语法和future搭配使用。将一个返回对象包装起来，并将它的返回值传回future，从而实现线程间的通信。
   
   - socket

# 27. 线程间的数据同步、数据竞争

数据同步是多个线程对共享数据的访问需要进行协调和同步，以确保数据的一致性和正确性。

数据竞争是指多个线同时访问和修改一个共享变量，且至少有一个线程对该变量进行写操作。当多个线程对数据进行读写时，由于顺序不一致，导致最终数据不一致性，不可预测行为和程序崩溃。可以使用同步机制确保共享资源的有序访问与修改。

1. 互斥锁
   
   保证任何一个时刻只有一个线程访问mutex保护的临界区。
   
   使用RAII手法来封装mutex的创建、销毁、加锁、解锁。lock_guard将mutex的创建和销毁交给guard的构造和析构函数。

2. 条件变量，互斥锁是加锁源于，条件变量是等待原语。学名为管程。
   
   对于wait端：
   
   - 必须与mutex一起用，该布尔表达式的读写受此mutex的保护。
   
   - 在mutex已上锁的时候才能调用wait
   
   - 把判断布尔条件和wait()放到while循环中，而不能使用if。原因是spurious wakeup
   
   对于signal/broadcast端：
   
   - 不一定要在mutex已上锁的情况下调用signal
   
   - 在signal之前一般要修改布尔表达式的值
   
   - 修改需要用mutex保护
   
   - broadcast通常表示状态变化，而signal通常表示资源可用。

3. 信号量：条件变量加互斥器可以代替信号量，且更不易用错。

4. 读写锁
   
   如果临界区很小，锁竞争不激烈，mutex往往更快

5. atomic：
   
   原子变量在内部是使用自旋锁，对每一个访问该变量的线程自动加锁，使得访问更安全。

# 28. 锁的类型

互斥锁，条件锁，自旋锁，读写锁，递归锁

互斥锁：保证对某一共享资源互斥访问

条件锁：条件变量

自旋锁：一种busy-waiting的锁，会不断检查是否可以执行。而mutex是sleep-waiting锁，处理器不会因为线程被阻塞而是去处理其他事务。

读写锁：

递归锁：可重入互斥锁、同一线程对其多次加锁不会产生死锁，使用引用计数机制，以便可以从同意线程多次加锁、解锁，当加锁解锁次数相等时，才可以被其他线程获取。

# 29. 说一下布隆过滤器的原理

底层是一个大位数组，和多个无偏hash函数

对于一个key经过多个hash函数的计算，得出多个值，令数组的对应下标置为一。

判断至少有一个为0那么一定不存在，如果都为零，由于hash冲突也不一定存在。

防止缓存击穿：在分布式缓存系统中，当一个缓存失效后，如果直接查询数据库或后端系统，可能会引起大量的请求涌入，导致性能下降。使用布隆过滤器可以在查询缓存之前，判断元素是否存在于系统中，避免不必要的查询操作。

# 30. 一致性哈希

非一致性哈希会导致当机器增加或者减少的时候的数据迁移。

一致性哈希保证机器增加或者减少时，结点间的数据迁移只限于两个节点之间，不会造成全局的网络问题。

使用环状空间代替原来的线性空间

数据落在环上后，顺时针找到环上的第一个节点。

同样有一些问题：

1. 数据倾斜
   
   如果环比较大，较少的服务节点聚集在一起，可能会导致个别节点压力过大。

2. 节点雪崩
   
   当数据倾斜的时候一旦某个节点宕机会将压力转移到下一个节点，从而导致连串反应器。

可以使用虚拟节点来解决上面的两个问题

对原来的物理节点在哈希环上虚拟出几个它的分身节点，这些节点被称为虚拟节点。打到分身节点上的数据也映射到分身对应的物理节点上，这样一个物理节点可以通过虚拟节点的方式分散在哈希环的各个部分。

而当节点下机时它的数据也会分散给其他节点。

# 31. 网络包的路由过程

1. 路由器首先提取报文的目的IP地址，然后查找路由表，将报文的目的IP地址与路由表中某表项的掩码字段做与操作，“与”操作后的结果跟路由表该表项的目的IP地址比较，相同则匹配上，否则就没匹配上。

2. 当与所有表项匹配后，路由器选择一个掩码最长的匹配项
   
   路由来源：分为直连路由，静态路由，缺省路由，动态路由
   
   链路层协议发现的路由（接口路由或直连路由），
   
   网络管理员手工配置的静态路由
   
   缺省路由：指明一些在下一跳没有明确地列于路由表中的数据单元该如何转发。对于不明确路由条目的所有数据包，按照缺省路由转发
   
   动态路由协议发现的路由

去往相同网段的路由，优先级相同时，路由开销小的会加入路由表

。如果路由器无法使用优先级判断，则使用度量值metric，越小的越优先。

如果metric值也相同，则多条相同的路由将实现等价负载分担。

路由器收到一个数据包后，会检查目的IP，然后根据最长匹配原则查找路由表。如果查找到路由表项之后，根据表项指示的出接口信息和吓一跳信息将数据包转发出去。如果没找到，会查找是否有缺省路由，都没找到就丢弃。

# 32. 如果实现了一个http server和一个http client，请求的时候可能会有一些请求超时和无响应，如何排查问题？如何判断是否是网络拥塞，如果服务器只能接受20个连接，同时有100个请求会发生什么？如果没成功建立连接客户端能感知到么？

确认网络连接正常。检查服务器运行状态。日志分析。连接数限制。网络拥塞判断：查看延迟情况，例如ping，看看其他服务是否正常。用top看网口负载。用ifconfig或者ip查看丢包数RX，TX，以及错误包数

查看队列情况，拥塞会导致排队的数据包增多，通过netstat查看入队未被处理的数量，分析内核日志搜索congestion，retransmission等。

# 33. 内存泄漏会导致什么问题？

1. 内存资源耗尽

2. 系统性能下降

3. 内存碎片化

# 34. OM
