# 面试题

## 1. 左值引用与右值引用的区别？右值引用的意义？

区别：

左值引用，是对左值的引用。避免对象的拷贝，比如函数传参，函数返回值

右值引用，是对右值的引用。实现移动语义，实现完美转发。

区分左值右值，可以在等号左边，可以取地址并且是具名的。比如变量名，返回左值引用的函数调用，前置自增自减、

右值只能在等号右边，不能取地址，不具名。

通常字面量是一个右值，除了字符串字面量。

## 左值引用

让C++编程一定程度上脱离了危险的指针。

举例：在函数传参的时候，函数返回

非常量左值的引用对象必须是一个左值，而常量左值的引用对象可以是一个右值。举例，复制构造函数和复制赋值运算符函数。通常情况下实现的两个函数的形参都是一个常量左值引用。虽然常量左值引用可以绑定到右值，但是也存在一个缺陷：常量性。一旦使用的常量左值引用，那么就无法在函数内修改该对象的内容（强制类型转换除外）。所以需要另外一个特性来完成这项工作，就是右值引用

## 右值引用

右值引用顾名思义，是一种引用右值且只能引用右值的方法。添加&&。

右值引用的特点就是可以延长右值的生命周期。

比如

```cpp
#include <iostream>

class X{
    X(){ cout << "X ctor" << endl; }
    X(const X&x) { cout << "X copy ctor" <<endl; }
    ~X() { cout << "X ctor" << endl; }
    void show() { cout << "show X" <<endl; }
};

X make_X(){
    X x1;
    return x1;
}

int main(){
    X &&x2=make_X();
    x2.show();
}
```

这里使用了右值引用，那么可以减少X &&x2=make_X();这条语句的一次复制构造函数的调用。

右值引用的最终目标是减少对象的复制，提升程序的性能。

## 右值的性能优化空间

很多情况下，右值存储在临时对象中，当右值被使用后程序会马上销毁对象并释放内存。这可能会引发一个性能问题。

```cpp
#include <iostream>
using namespace std;
class BigMemoryPool{
    public:
        static const int PoolSize - 4096;
        BigMemoryPool() : pool_(new char[PoolSize]){}
        ~BigMemoryPool(){
            if(pool_){
                delete[] pool_;
            }
        }
        BigMemoryPool(const BigMemoryPool& other) : pool_(new char[PoolSize){
            cout << "copy big memory" <<endl;
            memcpy(pool_, other.pool, PoolSize);
        }
    private:
        char *pool_;
};


BigMemoryPool get_pool(const BigMemoryPool& pool){
    return pool;
}
BigMemoryPool make_pool(){
    BigMemoryPool pool;
    return get_pool(pool);
}

int main(){
    BigMemoryPool my_pool = make_pool();
}
```

以上会调用三次复制构造函数

1. get_pool返回的临时对象调用复制构造函数复制了pool对象。

2. make_pool返回的BigMemoryPool临时对象调用了复制构造函数复制了get_pool返回的临时对象。

3. main函数中的my_pool调用复制构造函数复制了make_pool返回的临时对象。

## 移动语义

上面代码的2，3是主要影响性能的关键。如果可以将临时对象的内存直接转移到my_pool中就好了。可以使用移动语义。

```cpp
class BigMemoryPool{
    public:
        static const int PoolSize - 4096;
        BigMemoryPool() : pool_(new char[PoolSize]){}
        ~BigMemoryPool(){
            if(pool_){
                delete[] pool_;
            }
        }
        BigMemoryPool(BigMemoryPool&& other) : pool_(new char[PoolSize){
            cout << "move big memory pool" <<endl;
            pool_ = other.pool_;
            other.pool_ = nullptr;
        }
        BigMemoryPool(const BigMemoryPool& other) : pool_(new char[PoolSize){
            cout << "copy big memory" <<endl;
            memcpy(pool_, other.pool, PoolSize);
        }
    private:
        char *pool_;
};
```

增加一个移动构造函数。移动构造函数的形参是一个右值引用，其核心思想是通过转移实参对象的数据以达到构造的目的。

对于右值编译器会优先选择移动构造函数。当不存在是才选择复制构造函数。

移动赋值运算符也可以完成

```cpp
class BigMemoryPool{
    public:
        ...
        BigMemoryPool& operator=(BigMemoryPool&& other){
            cout << "move(operator=) big memory pool" <<endl;
            if(pool_) delete[] pool_;
            pool_ = other.pool_;
            other.pool_ = nullptr;
            return *this;
        }
    private:
        char *pool_;
};
```

移动语义的使用是有风险的，如果出现异常没那么对象将只转换一半，所以一般使用noexcept限制这个函数，如果出现异常就调用std::terminate终止程序执行。

## 值类别

表达式被分为泛左值和右值，其中泛左值进一步被分为左值和将亡值，右值进一步被分为将亡值和纯右值。

1. 所谓泛左值是指一个通过评估能够确定对象、位域或函数的标识的表达式。简单来说，他确定了对象或者函数的标识。（具名对象）

2. 纯右值是指一个通过评估能够用于初始化对象和位域，或者能够计算运算符操作数的值的表达式。

3. 将亡值属于泛左值的一种，它表示资源可以被重用的对象和位域，通常这是因为它们接近生命周期的末尾，另外也可能是经过右值引用的转换产生的。

值类别都是表达式的属性，所以常说的左值右值实际上指的是表达式。

左值就是C++98的左值，纯右值就是C++98的右值。

将亡值：

从本质上说产生将亡值的途径有两种：

1. 使用类型转换将泛左值转换为该类型的右值引用。static_cast<BigMemoryPool&&>(my_pool)。

2. 在C++17中引入，临时量实质化，指的是纯右值转换到临时对象的过程。每当纯右值出现在一个需要泛左值的地方时，临时量实质化都会发生，也就是说都会创建一个临时对象并且使用纯右值对其进行初始化，而这里的临时对象就是一个将亡值。
   
   ```cpp
   struct X{
       int a;
   };
   int main(){
       int b = X().a;
   }
   ```

X()是一个纯右值，访问其成员变量a却需要一个泛左值，所以这里会发生一次临时量实质化，将X()转换为将亡值，最后再访问其成员变量a。在C++17标准之前临时变量是纯右值，只有转换为右值引用的类型才是将亡值。

## 将左值转换为右值

右值引用像绑定到左值，就需要将左值转换为将亡值，move或static_cast。

在函数传参的时候，无论一个函数的实参是左值还是右值，形参都是左值，尽管这个形参看上去是一个右值引用。这个时候可以使用移动语义对形参进行处理以提高性能。（调用移动构造函数或移动赋值运算符函数，避免复制）

## 万能引用和引用折叠

T&& auto&&

正常右值引用只能引用右值，而如果是模板类型或auto类型则没有这个限制。

其实其因为，在这里发生了类型推导。究其原因是因为C++11中添加了一套引用叠加推导的规则---引用折叠。

类模板型如果是左值引用，那么不管T实际类型是什么都推导出R&

类模板型是右值引用，那么除非实际类型是引用，否则推导出的都是右值引用。

## 完美转发

万能引用的典型用途就是完美转发。避免产生多余的复制。同样注意形参为左值的问题。这里可以使用std::forward函数模板

```cpp
template <class T>
void perfect_forwarding(T &&t){
    show_type(std::forward<T>(t));
}
```

注意与move的区别，move一定会将实参转换为右值引用，并且不需要模板实参，它是被推导出来的。forward则会根据左值右值的情况进行转发，使用的时候需要指定模板实参。

# 2. malloc是如何分配内存的

malloc分配的是虚拟内存，

进程虚拟内存空间分布：从低地址往高走，代码段（二进制可执行代码），已初始化数据段（静态常量），未初始化数据段（未初始化的静态变量），堆段（从低往高扩展，动态分配），文件映射段（动态库，共享内存等），栈段（由高往低地址，局部变量，函数调用上下文等），内核空间（所有进程共享）。

可执行文件装载时，内核就为数据段分配好虚拟地址和物理页面，并建立好二者的映射关系。

只有在使用的时候才会具体分配物理内存，调用malloc不会分配真实的物理内存。

怎么分配物理内存？缺页异常

如何分配？内存小于128K，通过系统调用*brk*从堆段分配，大于等于128K，通过*mmap*系统调用从文件映射段分配。

malloc是不是系统调用名？不是，是库函数。

优先从内存池中分配， 作用：减少系统调用的次数，减少缺页异常的次数。缺点，增加内存碎片。

# 3. free怎么知道释放多少内存

释放内存后，内存还在么？

通过brk分配的，free后回收到内存池中，

mmap分配的，归还到操作系统。

会多分配16字节用来记录元信息，释放的时候，指针向左移动十六位然后根据元信息释放空间。

# 4. 写文件时进程宕机，数据会丢失么？

写文件的机制：

stdio库：stdio缓冲区（用户空间缓冲区），可以通过setbuf自定义缓冲区，

fflush（内部调用write，把用户缓冲区刷到内核缓冲区page cache)。

page cache减少磁盘io次数。缺点：无法优化page cache的策略，这也是为什么数据库要维护一个page cache管理。

fsync（指定fd）, fdatasync把内核缓冲区刷到磁盘。

sync把所有打开文件全部刷盘。

两种磁盘io方式：缓存文件io，文件io（用户缓冲区直接到磁盘中没有page cache）。

写文件，还没调用fflush（write），数据百分百丢失了，因为数据在用户空间，

调用了fflush（write），数据不会丢失，在内核缓冲区

如果系统关闭前，调用直接文件io且已经调用了write，数据不会丢失。使用缓存文件io如果系统关闭了那么数据也丢失了。

大文件使用直接文件io，小数据使用缓存文件io。

# 5. 什么是MTU、MSS以及为什么要有MSS？

# 6. 智能指针种类以及使用场景

悬垂指针、野指针、踩内存，内存泄漏，重复释放

shared_ptr：内部存在一个引用计数，为零的时候析构，按照对象来进行管理

weak_ptr：解决shared_ptr的循环引用问题。

unique_ptr：独享所有权

# 7. 谈谈C++多态

C++的四种多态：运行时多态，编译时多态，重载，强制多态

## 运行时多态

通过基类的指针或者引用来使用派生类

## 参数多态（编译时多态）

对任何类型执行相同代码。通过模板来实现

## 重载多态

允许函数拥有相同的函数名而对不同的类型的数据执行不同的动作

## 强制多态（类型转换）

将一个对象或者类型强制转换成另外一种对象类型。

# 8.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     22`
