# 并发编程

## 互斥锁如何实现公平？

Mutex有两种状态，正常状态和饥饿状态，处于正常状态下，所有等待锁的goroutine按照FIFO等待。刚换醒的进程不会直接拥有锁，而是会和新请求锁的goroutine竞争，当一个等待的goroutine超过**1ms**没有获取锁，就把它转为饥饿模式，饥饿模式下，锁的所有权将从unlock的goroutine直接交给等待队列中的第一个。新来的goroutine将不会尝试去获得锁，即使锁看起来是unlock状态，也不会尝试自旋操作，而是放在等待队列的尾部。

如果一个等待的goroutine获取了锁并且它是等待队列的最后一个或者它等待的时候小于1ms。它会将锁转变为正常状态。

正常状态有很好的性能表现，饥饿模式可以阻止尾部延迟的现象

# 
