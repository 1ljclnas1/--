# 链接装载库

## 内存、栈、堆

一般应用程序内存空间有如下区域

- 栈：由操作系统自动分配与释放，存放函数的参数值、局部变量等，用于维护函数调用的上下文

- 堆：一般由程序员分配释放，若不释放则在进程结束后由操作系统回收

- 可执行文件映像：存储可执行文件在内存中的映像，由装载器装载是将可执行文件的内存读取或映射到这里

- 保留区：堆内存中受到保护而禁止访问的内存区域的总称，

### 栈

栈保存了一个函数调用所需要的维护信息，通常称为堆栈帧或活动记录，一般有以下几个：

- 函数的返回地址和参数

- 临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量

- 保存上下文：包括函数调用前后需要保持不变的寄存器

### 堆

堆分配算法：

- 空闲链表

- 位图

- 对象池

## 编译链接

### 编译连接过程

1. 预编译（预处理如#include、#define等预编译指令，生成.i或.ii文件）

2. 编译（编译器进行词法分析、语法分析、语义分析、中间代码生成、目标代码生成、优化，生成.s文件）

3. 汇编（汇编器把汇编码翻译成.o文件）

4. 链接（连接器进行地址和空间分配、符号决议、重定位，生成.out文件）

### 目标文件

编译器编译源代码后生成的文件叫目标文件。目标文件从结构上讲，它是已经编译后的可执行文件格式，只是还没有经过链接的过程，其中可能有些符号或有些地址还没有被调整

#### 目标文件格式

- Windows的PE，或称为PE-COFF，.obj格式

- Linux的ELF，.o格式

- Intel/Microsoft的OMF格式

- Unix的a.out格式

- MS-DOS的.COM格式

#### 目标文件存储结构

文件头，代码段，数据段，bss section（未初始化的全局变量和局部静态变量），.rodata section（只读数据段，存放只读数据和字符串常量），.comment section注释信息段（存放编译器版本信息），.note.GNU-stack section（堆栈提示段）

#### 链接的接口-符号

在链接中，目标文件之间相互拼合实际上是目标文件之间对地址的引用，即堆函数和变量的地址的引用。我们将函数和变量统称为符号，函数名或变量名就是符号名。

### Linux的共享库(Shared Library)

就是普通的ELF共享对象

共享版本更新应该保证二进制接口ABI的兼容

#### 命名

libname.so.x.y.z     x主版本（不用兼容），y次版本（高兼容低），z发布版本号（不对接口更改）

#### 路径

大部分包括Linux在内的遵循FHS的标准，标准规定了系统文件如何存放，包括各个目录结构、阻止和作用

/lib 系统最关键的和最基础的共享库

/usr/lib  非关键的库，主要是开发库

/usr/local/lib  第三方库

#### 环境变量

- LD_LIBRARY_PATH: 临时改变某个应用程序的共享库查找路径

- LD_PRELOAD: 指定预先装载的一些共享库甚至目标文件

- LD_DEBUG: 打开动态链接器的调试功能

### 


