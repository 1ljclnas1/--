# 5. 数据复制

**可能出错和不可能出错的事物的区别在于，当一个不可能出错的事物出错了通常意味着不可修复**

数据复制的目的：

- 降低访问延迟，更接近用户

- 提高可用性，当部分组件出错

- 提高读吞吐量，扩展多台机器同时提供读服务。

所有数据复制技术的挑战都在于如何处理**持续变更的数据**

三种流行的复制数据变化的方法：**主从复制、多主节点复制、无节点复制**

复制技术存在许多需要折中考虑的地方，比如采用<u>**同步复制还是异步复制**</u>，以及<u>**如何处理失败的副本**</u>。

## 主节点与从节点

保存完整数据集的节点称之为副本。当有了多个副本之后需要考虑：**如何确保所有副本之间的数据是一致的**

最常见的是**主从复制**：

1. 指定一个主副本。当客户写数据库时，必须先发给主副本，主副本先写入自己的本地数据库

2. 其他副本为从副本。主副本写入后，将数据更改作为复制的日志或更改流发送给所有从副本。每个从副本获得更改日志后，应用至本地数据库，且严格保证与主副本相同的写入顺序。

3. 客户端从数据库中读的时候可以从主副本读也可以从从副本读。

主从复制技术不只是局限于数据库，比如kafka，RabbitMQ，以及一些网络文件系统和复制块设备（如DRBD）。

## 同步复制与异步复制

同步：主节点等待从节点写入成功后返回。

异步：主节点发送完数据变更的消息之后，立即返回，不等待从节点的返回。

同步的优点：从节点可以明确保证完成了主节点的数据更改，并处于最新状态，万一主节点发生故障，可以在从节点访问最新的数据。

同步的缺点：如果从节点无法完成确认（节点故障或网络故障），写入就不能成功，而主节点也会因此阻塞后续写入操作。

因此，如果把所有节点都配置为同步复制就不太现实。如果一个数据库系统启动了同步复制，通常是一个从节点是同步的，而其他从节点是异步的。当同步的从节点性能下降或故障时，可以将一个异步的从节点提升，从而保证有两个节点拥有最新的数据。这种叫做**半同步**

主从复制还有**全异步模式**，此时如果主节点故障，那么尚未复制到从节点的数据全部丢失。这意味着即使客户端确认了写操作，但是也无法保证数据持久化。全异步优点：不管从节点数据多么滞后，总是可以响应，系统的吞吐性能好。

## 处理节点失效

如何同步主从复制提高节点可用性？

### 从节点失效：追赶式恢复

请求在节点失效期间的数据更改

### 主节点失效：节点切换

比较棘手：**选择**某个从节点将其提升为主节点；**客户端**也要**更新**，这样之后的**写请求会发送给新的主节点**，然后**其他节点**要接受来自**新的主节点**的变更数据。

自动切换：

1. 确认主节点失效：由于出错的可能性太多（系统崩溃，停电，网络分区），因此没有万无一失的检测方法，能检测问题出在哪里，大多数系统采用**超时机制**：节点间频繁交换心跳信息，如果发现某一个节点在一段比较长的时间内没有响应，就认为该节点发生失效。

2. 选举新的主节点：可以通过选举的方式（共识）来选举新的主节点。候选节点最后数据差异与原主节点最小。

3. 重配置系统使新主节点生效：客户端需要将新的请求发送给新主节点，原主节点上线后自动降级为从节点。

这里面存在太多的问题需要解决：

- 如果使用异步复制，当主节点失效后，客户端可能收到了数据应用成功的响应，而这时原主节点的数据有部分没有同步到新的主节点上，而如果这时候原主节点上线后，发现自己不是主节点了，那么就会选择丢掉这部分数据以防止产生冲突的写请求，从而造成幽灵日志。而当原主节点丢掉这部分数据后，就会违背数据更新持久化的承诺。

- 如果有其它系统依赖数据库系统运行，那丢掉数据的行为就非常危险。比如GitHub的一个事故，MySQL的一个非完全同步的节点被提升为主节点，数据库使用自增计数器将主键分配给新建的行，但是由于它落后于原主节点，导致它重新使用了已被分配出去的主键，而这些主键恰好被外部的Redis使用，结果就出现了MySQL和Redis不一致，最后导致某些私有数据的泄露。

- 在某些情况下，可能会出现脑裂的问题，这个是非常危险的：两个主节点都会接收写请求，并且没有很好的解决冲突的办法，最后数据可能会丢失或者被破坏。

- 如何设置超时的时间来检测主节点失效？太长会导致总体恢复时间太长，太短会导致频繁的切换，例如负载高峰期，如果系统此时处于高负载压力，或玩咯出现严重拥堵。

## 复制日志的实现

### 基于语句的复制

就是把语句复制过去执行

有几个不适用的场景：

- 任何调用非确定性函数的语句如Now()等

- 如果语句中使用了自增列或者依赖于数据库的现有数据（如UPDATE WHERE），则副本的执行顺序必须完全一致，否则可能结果不一致。进而，如果有多个同时并发执行的事务，会有很大的限制。

- 有副作用的语句，可能在不同的副本上产生不一致的结果

对于不确定性的函数可以使用替换。

### 基于预写日志（WAL）传输

每个写操作都是以追加写的方式写入到日志中：

- 对于日志结构存储引擎，日志是主要的存储方式，日志段在后台进行压缩和垃圾回收

- 对于采用覆盖写磁盘的Btree，每次修改会与先写入日志，如果系统发生崩溃，通过索引更新的方式可以迅速恢复至此前的一致状态。

不管哪种情况，数据修改的字节序列都被写入日志。因此可以使用完全相同的日志在另一个节点上构建数据副本：除了将日志写入磁盘，还可以将日志发送给其他节点。

主要缺点就是：日志描述的数据太底层了：一个WAL包含了哪些磁盘块的哪些字节发生改变，等类似这样的细节。这就使复制方案和存储引擎紧密耦合。如果存储格式变了比如两个节点是不同的数据库版本就会不兼容。这对运营来说影响太大了，如果软件向后兼容，那就可以不断迭代升级，可以先将从节点升级，在切换主节点为这个升级后的从节点，然后主节点升级，这样可以不停机升级，否则将会以停机为代价。

### 基于行的逻辑日志复制

复制和存储引擎采用不同的日志格式，这样复制和存储逻辑剥离。该技术也被称为变更数据捕获。

由于逻辑日志与存储剥离因此，更易于向后兼容。

### 基于触发器的复制

之前的三种都是由数据库系统来实现的，不涉及应用层代码。但是如果我们想只复制一部分或者从一种数据库复制到另一种数据库的时候，或者需要订制、管理冲突解决逻辑，则需要将复制控制交给应用程序层。

触发器支持注册自己的应用层代码，使得当数据库系统发生数据变更（写事务）时自动执行上述自定义代码。通过触发器技术，可以将数据更改记录到一个单独的表中，然后外部处理逻辑访问该表，实施必要的自定义应用层逻辑，比如将更改复制到另一个数据库系统（类似于回调的思路）。

## 复制滞后问题

主从复制比较适合读密集型的负载：创建多个副本，然后响应读请求。

但是这个比较多用异步复制，因为同步复制受限于网络，而网络是不可靠的并且存在单点问题。从而会导致系统无法写入。

而异步复制就会导致**暂时性的不一致**，但随着时间推移，从节点总会同步到与主节点一个的状态，这个就是**最终一致性**。而这就是**复制滞后问题**

### 读自己的写

在异步复制的情况下，用户写入后再读自己刚写入的数据，则新数据可能还没到达从节点，导致用户看起来刚写入的数据丢失了。这个时候就需要**写后读一致性**，也称为**读写一致性**。该机制保证如果用户重新加载页面，他们总是可以看到自己最近提交的更新。但是对于其他用户则没有保证，可能需要刷新才能看到。

有多种实现读写一致性的方案：

- 如果用户访问的是可能被修改的内容则在主节点读取，否则在从节点。比如社交网络上的：总是从主节点访问自己的首页配置文件，而在从节点访问其他用户的配置文件。

- 如果应用的大部分内容都可能被用户修改，那上面的方法可能不太行，它会导致主节点压力上升，并且丧失读扩展性。因此需要有其他的方法判断是否从主节点上读取，比如**跟踪最近更新的时间**，如果更新后一分钟内从主节点读取，不然在从节点读取。

- 客户端也可以记住最近更新时的时间戳，并附带在读请求中，据此信息，系统可以确保对该用户提供读服务时都应该至少包含了该时间戳的更新。如果不够新要么给另一个副本处理，要么等待知道副本接收到了最近的更新。可以是逻辑时间戳也可以是实际系统时间戳（这又涉及到了时钟同步）。

- 如果副本分布在多个数据中心，那必须先将请求路由到主节点所在的数据中心（可能很远）。

用户如果用了不同的设备也要保证写后读一致性，但是就比较困难了：

- 如果是记录上次更新时间戳的方式，比较费劲，因为不同设备的元数据需要共享

- 如果是路由到一个数据中心，那么PC走的是家庭宽带，手机走的是蜂窝数据网络，这就没法保证一定路由到同一个数据中心。

### 单调读

在异步复制读中，可能会因为复制滞后的问题而导致出现幽灵日志，比如用户发起了两次查询，第一次路由到了一个滞后不多的节点，看到了某些内容，而第二次路由到了滞后较多的节点，又看不到上次查询看到的内容。就好像是时间回拨了一样，这时候就需要保证**单调读一致性**

这是比强一致性弱，但比最终一致性强的保证。当读取数据的时候，单调读保证，用户依次进行读取，则他绝不会看到回滚现象，即读取新值后又读了旧值。

实现的方式是：确保每个用户总是从固定的同一副本执行读取。比如，基于用户ID的哈希的方式，而不是随机选择副本。

### 前缀一致读

当两个事件存在因果关系的时候如果第一个事件在分区1，第二个时间在分区2，事件1先发生，当它到达分区一的主节点后，又被发送给分区一从节点和事件二的发生者，然后由于复制滞后，到达分区一从节点的时间点很靠后，如果这时有一个观察者，当事件二到达分区二的从节点后事件二会到达观察者，而在这之后分区一从节点才到达了事件一再到达观察者，这就导致了逻辑上的混乱，事件二先于事件一发生了，此时就要保证**前缀一致读**。对于一系列按照某个顺序发生的写请求，读取的时候也要按照当时写入的顺序。

这是分区数据库出现的一个特殊的问题。数据总是以相同的顺序写入，那读取总是会看到一致的序列。但是在许多分布式数据库中，不同的分区独立运行，因此不存在全局写入顺序。这导致用户从数据库中读取数据的时候，可能会看到一部分旧值和另一部分新值。

一个解决方案就是，确保任何具有因果顺序关系的写入都交给一个分区来完成

### 复制滞后的解决方案

在使用**最终一致性系统**的时候，一定要先考虑：如果复制延迟增加到几分钟或者几小时的时候，应用层的行为是什么，如果带来了更糟糕的体验，那么可能就需要一个更强的一致性的保证。

应用层可以提供比底层数据库更强有力的保证，但是会变得比较复杂。

如果应用程序开发人员不必担心这么多的底层复制问题，而是假定数据库正在**做正确的事情**，那就简单了。而这个就是**事务**存在的原因，事务是数据库提供更强保证的一种方式。

但是在分布式当中，很多系统放弃的了事务，原因是性能和可用性方面的代价过高，并且断言可扩展的分布式系统中最终一致性是无法避免的终极选择。

## 多主节点复制

主从复制有一个明显的缺点：系统只有一个主节点，所有的写都要经过主节点，如果主节点崩溃或网络故障而下线的话，会影响所有的写入操作。

那么可以配置多个主节点，都接受写请求，然后将写请求转发。此时每个主节点还扮演着其他主节点的从节点。

### 适用场景

一个数据中心内部用多个主节点没什么意义。

#### 多数据中心

为了容忍整个数据中心级别的故障或者更接近用户，可以把数据库的副本跨多个数据中心。每个数据中心都可以有主节点，内部采用常规的主从复制。数据中心之间，由各个数据中心的主节点来负责同其他数据中心的主节点进行数据的交换、更新。

首先对于性能来说，多主节点的响应更为迅速，不必通过广域网路由至主节点所在的数据中心，每个数据中心都可以响应

其次是可以容忍数据中心失效，不必将另一个数据中心的某个从节点提升为主节点，数据中心恢复后可以快速恢复之后更新到的数据

再有容忍网络问题，数据中心之间的通信是经由广域网的而广域网远不如本地网络可靠，多主的异步复制可以更好的容忍此类问题。

但是多主有一个很大的缺陷就是：多个数据中心可能同时更改相同数据，，因此必须解决潜在的冲突。

#### 离线客户端操作

应用在与网络断开后还可以继续工作

比如手机上的日历。无论是否联网都应该可以查看当前的会议安排

这种情况下，每个设备有一个充当主节点的本地数据库（用于接受写请求），然后所有设备之间采用异步方式同步这些副本。从架构层面，基本等同于多数据中心的多主复制，只不过是一个极端情况，一个设备就是一个数据中心。

#### 协作编辑

允许多个用户同时编辑文档。

虽然与数据库复制不等价，但是有很多类似的地方

当一个用户编辑文档时，会立即将更改应用到本地副本，然后异步复制到服务器以及其他的编辑同一文档的用户。如果为了确保不发生编辑冲突，可以对文档加锁，这相当于主从复制模式下，在主节点执行事务操作。

为了加快协作效率，可以对单个按键加锁，甚至是全程无锁。

### 处理写冲突

多主复制最大问题就是写冲突。

#### 同步与异步冲突检测

多主模型中，冲突只能在稍后的时间点才会被检测出来，然而这个时候再通知用户就晚了，因为已经通知成功了。

如果等待写请求完成对所有副本的同步后再进行通知，那显然失去了多主的优势：允许每个主节点独立运行。

#### 避免冲突

处理冲突最理想的就是避免发生冲突，如果应用层可以保证对特定记录的写请求总是通过同一个主节点，这样就不会发生写冲突。从用户来看基本属于单主从复制。

但是，如果某个数据中心坏了，就需要改变实现预定的数据中心，或者是用户漫游到了另一个位置，更靠近另一个数据中心，需要重新路由的时候，就需要考虑处理同时写入冲突的可能性。

#### 收敛于一致状态

由于多主模型，由于不存在确定的写入顺序，从而导致最终值也是不确定的。

如果每个副本只是按照它所看到的写入顺序执行的话，那么数据库最终不会达到一致状态。

实现收敛的冲突解决可能有几种方式：

- 给每个写入分配唯一的ID，挑选最高ID的写入为胜利者，将其他丢弃。

- 为每个副本分配一个唯一的ID，并制定规则，例如高的总是优先于低的。这种方法也可能会造成数据丢失。

- 以某种方式将这些值合并在一起，比如”B/C/D/E“等

- 利用预定义好的方式来记录和保留冲突信息，然后依靠应用层的逻辑，事后解决冲突。

#### 自定义冲突解决逻辑

解决冲突最合适的是依靠应用层。

解决冲突通常用于某个行或文档，而不是整个事务。如果一个事务包含多个写，通常分开考虑解决冲突

#### 什么是冲突？

两个同时写就是冲突。

还有一些比较微妙的：

通常是由滞后引起的

### 拓扑结构

复制的拓扑结构描述了写请求从一个节点的传播到其他节点的通信路径。如果有两个主节点：则只有一种合理的拓扑结构：主节点1必须把所有写同步到主节点2，反之亦然。但如果是两个以上则可能有多个合理的拓扑i结构：环形拓扑，星形拓扑，全部至全部型拓扑。

采用星形或者环形，很容易出现单点故障问题，导致消息传播受阻，此时通常需要手动配置

而全链接的一个问题就是网络延迟导致以外的写日志复制顺序。

而由于无法确保时钟同步，因此简单的加时间戳还不行，为了使日志消息正确有序，可以使用版本向量的技术。

## 无主节点复制

之前的那些都是由主节点决定写入顺序，并发送给从节点。然而一些数据存储系统采用了不同的设计思路：选择放弃主节点，允许任何副本直接接受来自客户端的写请求。其实最早的数据复制系统就是无主节点的，只不过当关系型数据库主导时代后，这个就渐渐被遗忘了。但是当亚马逊内部采用了Dynamo系统之后，无主复制又变的时髦了。

有一些是客户端直接将写请求发送到多副本，有一些是将写请求发到协调者节点，但是协调者跟主节点不一样，协调者不维护写入顺序。

### 节点失效时写入数据库

可以在用户那边实现多数派思想，写请求发给多个节点，只要有超过一半的节点写入成功，就认为写入成功，但是这样的话读取的时候也需要是同时申请多个副本，然后选一个最新的。

#### 读修复与反熵

当一个失效节点重新上线后如何追赶数据？

Dynamo风格的数据存储系统通常使用以下两种机制：

- 读修复：当客户端读取多个副本时，比较过期的值，并将新的值写入进去。适用于被频繁读取的场景

- 反熵过程：此外，一些数据存储有后台进程不断查找副本之间数据的差异，将任何缺少的数据从一个副本复制到另一个副本。与主节点不同，这个不保证写入顺序，并且会引入明显的同步滞后。

#### 读写quorum

三个副本中，如果两个以上完成处理，认为写入成功。

我们认为有n个副本，写入成功w个，读取至少查询r个，满足**w+r>n**。

w和r被称为法定写数和法定读数。

n通常是基数，因为如果是偶数将会有一个没必要的节点。通常**w=r=(n+1)/2**。

#### Quorum一致性的局限性

quorum不一定需要是多数，读写节点集合至少有一个节点是重合才是关键。

但是即使是w+r>n也可能存在返回旧值的边界条件：

- 如果采用了sloppy quorum写操作的w节点和读取的r节点可能完全不同，因此无法保证读写请求一定存在重叠的节点。

- 如果两个写操作同时发生，则无法明确先后顺序。这时候就只能合并并发写入了。依然不能依靠时钟（时钟不可靠）

- 写和读同时发生，一部分部分写入，但是读的是另一部分

- 如果某个节点失效但是数据的恢复来自于一个旧数据的节点，那么可能导致新值的副本数量少于w

#### 监控旧值

从运维角度来看，监控数据库返回的是否是旧值是很有必要的，如果出现了明显的滞后，可能需要手动排查原因。对于主从复制只需对比偏移量差值就知道落后多少，但是对于无主来说，没有固定的写入顺序，监控就很难。

如果只采用读修复的话，某些很少被访问的值可能会很旧。

#### 宽松的quorum与数据回传

写入和读取仍然需要w和r个节点，但包含了可能不在先前指定的n个节点。

当出现网络中断的时候，一个客户端和多个节点的链接被切断，尽管这些节点是活着的。这种情况下可能无法满足w和r的要求。

但是这个时候可以采取一个措施：将写请求暂时存入一个临时节点（不在先前指定的n个节点中），等待网络恢复之后在进行**数据回传**。但是这就意味着及时满足w+r>n也不能保证读到的是新值，因为新值可能在n之外的某个节点上还没有回传回来。

因此sloppy quorum更像是为了数据持久化做的设计。

#### 多数据中心操作

无主节点复制旨在更好的容忍并发写入冲突，网络中断和延迟尖峰等。

跨数据中心的复制在后台异步执行，客户端只等待来自本地数据中心内的quorum节点数的确认。

### 检测并发写

Dynamo风格的数据库允许多个客户端对相同的主键同时发起写操作

一个核心问题是，由于网络延迟不稳定或者局部失效，请求在不同的节点上可能会呈现不同的顺序。

#### 最后写入者获胜（丢弃并发写入）

每个副本总是保存最新值，允许覆盖并丢弃旧值。

这个方法的关键点就在于**如何定义最新**

当支持写入并发的时候，其实就是意味着顺序的不确定。

即使无法确定自然顺序，也可以强制排序，比如加一个时间戳。(LWW)

LWW可以实现最终的一致性，但是以牺牲数据的持久性为代价。

LWW甚至会删除那些非并发写。

在一些可以接收覆盖写的场景LWW是可以被接受的。

要想确保LWW安全且无副作用，唯一的方法就是值写入一次然后写入值视为不可变。

#### Happens-before关系和并发

如果两个 操作都不在另一个之前发生，那么操作是并发的。

并发需要解决冲突问题。

事实上，操作是否在时间上重叠并不重要。如果两个操作并不需要意识到对方，即可声称是并发的。

#### 确定前后关系

可以使用版本号

- 服务器为每个主键维护一个版本号，每当主键新值写入时递增版本号，并将新版本号与写入的值一起保存。

- 当客户端读取主键时，服务器将返回所有（未被覆盖的）当前值以及最新的版本号。且要求写之前，客户端必须先发送读请求。

- 客户端写主键，写请求必须包含之前读到的版本号、读到的值和新值合并后的集合。写请求的响应可以像读操作一样，会返回所有当前的值。

- 当服务器收到带有特定版本号的写入的时候，覆盖该版本号或更低版本的所有值，但必须保存更高版本号的所有值。

#### 合并同时写入的值

当有删除操作的时候不能简单的进行合并，

系统必须保留一个对应的版本号以恰当的标记该项目需要在合并时被剔除。这种删除标记被称为**墓碑**

#### 版本矢量

如果有多个副本没有主节点的情况下，单个版本号就不够用了。

因此需要为每个副本和每个主键均定义一个版本号，并跟踪从其他副本看到的版本号。这个版本号集合就是版本矢量。

## 小结

复制或多副本技术主要服务于以下的目的：

- 高可用性

- 连接断开与容错

- 低延迟

- 读可扩展性

三种多副本方案：

主从复制：

    所有客户端的写都发给主节点，主节点将更改事件发给从节点，并保证顺序性

多主节点复制：

    多个主节点接受写，主节点负责将写同步到其他主节点

无主节点复制：

    客户端将写发送给多个节点上，读也从多个节点读，以检测和纠正数据（读修复）。此外还有反熵过程。

多主和无主更可靠，但是带来的是系统的复杂性和弱一致性保证。

复制可以同步也可以异步，一旦发生故障两种行为的表现差异对系统行为会产生深远影响。系统稳定时，异步优秀。但是要注意一旦发生提升，要意识到最新的数据可能会丢失。

对于复制滞后问题：

- 写后读一致性，保证用户总能看到自己所提交的数据（读自己的写）

- 单调读：用户在某个时间点读到数据之后，保证不会出现更早的数据。一种方式是每个用户总是从固定的同一副本读

- 前缀一致读：保证数据之间的因果关系。分区数据经多副本复制后出现了不同程度的滞后，导致观察者先看到果后看到因。
