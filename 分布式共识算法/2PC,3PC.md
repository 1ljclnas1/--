# 2PC,3PC----分布式事务的解决方案

## 二阶段提交协议

由于各个分支事务只能知道自己执行的结果是成功还是失败，并不清楚其他分支事务的执行结果，因此需要设计一个协调者的身份，各个分支事务向协调者上报执行状态，再由协调者根据各个分之十五的执行结果决定全局事务的提交或者回滚。

- 协调者：可以由事务发起者充当，也可以有第三方组件充当，如Seata的TC角色。协调者维护全局事务和分支事务的状态，驱动全局事务和分支事务提交或回滚。

- 参与者：通常由各个资源管理者充当，负责执行各个分支事务提交或回滚，并向协调者汇报执行状态。

准备阶段和提交回滚阶段。第一阶段用于各个分支事务的资源锁定，第二阶段用于全局事务的提交和回滚。、

准备阶段：

1. 开启全局事务：协调者收到客户端请求后，将各个分支事务需要处理的内容通过Prepare请求发送给各个协调者，并等待回复

2. 处理分支事务：收到协调者的Prepare请求后锁定事务资源，然后尝试执行各自的分支事务，记录Undo和Redo信息，但不提交。

3. 汇报分支事务状态：参与者根据（2）步执行的结果，相协调这汇报各自的分支事务状态。Yes/No

提交回滚阶段：

1. 驱动全局事务提交/回滚：如果协调者在约定的时间期限内收到所有参与者的Yes则触发全局事务提交，否则回滚。

2. 提交/回滚分支事务：根据Undo/Redo信息对各自分支事务进行提交/回滚，并释放第一阶段的锁定事务资源。

3. 汇报分支事务状态：参与者在处理提交/回滚分支事务后，相协调这反馈自己负责的分支事务状态。

4. 关闭全局事务。

主要掌握以下两点：

- 应用场景：适用于强一致性场景。例如，分布式事务中，多个分支事务组成的整体操作需要具备原子性。

- 核心思想：将一个事务拆分为两个阶段，先尝试后提交，以实现事务的原子性。

### 故障恢复

完善二阶段提交协议

#### 协调者发生故障

当协调者发生故障后，备用节点称为新的协调者参与进来。如果新上任的协调者像保证正确性，就要完成上一任未完成的任务。分为两种情况：

1. 如果上一任协调者在处理最后一条全局事务中已经完成了第二阶段的所有工作，那么新的协调者自然不需要做任何操作。但如果上一任在发送Prepare后发生故障，此时所有正常处理了Prepare请求的参与者都处于阻塞状态，所需的事务资源也处于锁定状态。此时新上任的协调者需要完成第二阶段的工作。至于新上任的发送Commit还是Rollback需要先询问所有参与者第一阶段执行的情况。

2. 第二种情况是，上一任已经开始了第二阶段的工作，但只部分发送了Commit或Rollback，还有一部分未收到。新上任的协调者在询问所有参与者时，如果有参与者执行了Commit或者Rollback，协调者通知其他参与者执行相同的指令。

#### 部分参与者发生故障

参与者发生故障，新的参与者加入集群后也要继续完成发生故障的参与者未完成的工作。

第一种情况：当故障的参与者完成了第一阶段工作，并回复给协调者之后发生故障，导致没有收到协调者的Commit或Rollback指令，此时，通常是新的参与者主动询问协调者。询问最后一条事务的执行指令，并完成相应工作，并释放资源。

第二种情况：参与者未完成第一阶段工作，协调者因等待参与者超时而发起Rollback请求，通知其他参与者进行事务回滚，并释放事务资源。

这种情况下，新加入的参与者感受不到最后一条事务的存在，自然不需要做额外的工作，也能保持协议的正确性。

### 二阶段的优缺点

简单，易于理解。

同步阻塞、数据不一致、单点问题和脑裂

同步阻塞：二阶段协议的阻塞主要体现在参与者需要协调者的指令才能执行第二阶段的操作。当协调者发生故障的时候，参与者在第一阶段锁定的事务资源无法释放。

数据不一致：在第二阶段，如果因为网络异常而导致一部分参与者收到Commit请求，而另一部分参与者没有收到Commit请求，那么结果将是一部分参与者提交了事务，二零一部分参与者无法提交。

单点问题和脑裂：

- 单点问题：二阶段协议过于依赖协调者。协调者发生故障的时候，整个集群将不可用

- 脑裂：当出现多个协调者的时候，将不能保证二阶段协议的正确性。

### 空回滚和防悬挂

空回滚是指第一阶段，发生网络丢包时，协调者发送的Prepare请求没有送达参与者。根据协调者超时规则，协调者等待超时后将会发送Rollback。如果此时网络恢复，那那些没有处理过第一阶段的工作的参与者将会进行空回滚。

在实现第二阶段提交协议的时候应该特别注意空回滚的情况。能够支持这种场景，而不会抛出客户端无法理解的异常。解决这个问题的常规方案是，由协调者生成一个全局唯一的XID，协调者每次发送请求时都需要携带XID，参与者在第一阶段将XID记录在日志中，在处理第二阶段的请求的时候，如果XID不在日志中则不予理会。

放悬挂：由于网络延迟导致Prepare请求在Rollback之后被参与者收到，在实际场景中，参与者应该拒绝迟来的Prepare请求。但是如何确定收到的Prepare请求是上一个事务还是一个新事务的开始呢？在空回滚的基础上，要拒绝空回滚之后到来的Prepare请求应该怎么办？这种情况就是防悬挂，需要在第二阶段处理之前也记录一条日志，在第一阶段查询该日志。如果查到了就抛弃这条Prepare请求。

## 三阶段提交协议

三阶段的流程为询问-->锁定事务资源-->提交事务

三阶段增加了超时机制，解决了协调者宕机时，参与者无法释放资源的问题

#### 阶段一：CanCommit询问阶段

1. 开启全局事务。协调者收到客户端请求后，向所有参与者发送CanCommit请求，询问是否可以执行本次事务。
2. 健康自检。参与者收到CanCommit后进行以下两个步骤：
   1. 检查自身健康。例如与协调者之间的链接
   2. 判断能否执行本次事务。
3. 汇报分支事务状态。

#### 阶段二：PreCommit预提交阶段

在询问阶段，如果协调者收到了至少一个No，或等待超时，则向所有参与者发送Abort请求。由于此时没有锁定任何资源，参与者只需要更改事务状态即可。

1. 驱动预提交。协调者由询问状态变为预提交状态，并向所有参与者发送PreCommit请求。
2. 处理分支事务。参与者收到PreCommit请求后，更改状态为PreCommit状态，同时记录Undo和Redo信息，尝试执行自己的分支事务。暂时不提交。
3. 汇报分支事务状态。

#### 阶段三：DoCommit提交阶段

如果协调者收到No或等待超时，则中断全局事务。中断过程如下：

1. 发送中断请求。

2. 分支事务回滚。根据Undo和Redo信息进行事务回滚。

3. 反馈回滚结果。

4. 关闭全局事务。

如果预提交阶段所有参与者为Yes，则执行提交事务请求。**经过前两个阶段的缓冲，如果参与者等待协调者超时，则参与者会执行提交事务。**

提交事务过程如下：

1. 发送提交请求。协调者变为提交状态，发送Commit请求。

2. 分支事务提交。参与者收到Commit后，更改状态为提交状态，并提交自己的分支事务，同时释放资源。

3. 反馈提交结果。

4. 关闭全局事务。

### 故障恢复

多数情况可以根据参与者自身的数据来执行对应指令

#### 1. 协调者发生故障

1. 如果协调者发生故障之前，全局事务处于第一阶段，那么所有参与者在等待协调者超时后，默认执行Abort指令。

2. 如果协调者发生故障之前，全局事务处于第二阶段，：
   
   - 如果所有参与者完成了第二阶段的工作，那么根据超时机制，所有参与者会提交事务。
   
   - 如果一部分完成了第二阶段工作，根据超时机制，会出现数据不一致的情况。一部分提交，一部分没提交。

3. 如果协调者发生故障之前，全局事务处于第三阶段，那么参与者等待超时后，自动提交事务。

解决数据不一致的问题的方法是引入心跳机制，让参与者时刻能监察到协调者的状况，而且心跳超时要远小于等待协调者的超时，这样才能察觉到异常。新上任的协调者，先询问所有参与者最后一条事务的执行情况，如果有一部分执行了Abort，则向所有参与者发送Abort请求，这样协议就恢复了。

#### 2. 部分参与者故障

参与者只需要向协调者获取全局事务状态即可。

1. 如果参与者故障之前，全局事务处于第一阶段，那么无论参与者是否完成第一阶段的工作，协调者在第二阶段都会发送Abort请求。中断全局事务，发生故障的参与者恢复后，可自行中断全局事务。

2. 如果参与者故障之前，全局事务处于第二阶段。
   
   - 参与者未完成第二阶段工作，协调者超时后，发送Abort请求。中断全局事务。参与者恢复后自行中断事务即可.
   
   - 参与者完成了第二阶段工作，可能反馈了Yes，也可能没有反馈。因此，需要向协调者询问情况后，再执行相应指令。

3. 如果参与者故障之前，全局事务处于第三阶段。无论是否完成都要询问协调者，因为其他的可能失败。

### 三阶段提交协议优缺点

是为了解决二阶段同步阻塞问题而诞生的。

1. 通过增加超时机制和自动提交/中断功能，减少参与者的阻塞范围。

2. 增加CanCommit阶段，降低了事务资源的锁定范围。

新的麻烦：

1. 多增加一个阶段，相当于增加了复杂度，同时多增加的RPC交互也会降低整个协议的协商效率。

2. 在某些情况下，必然会造成数据不正确。在三阶段，由于丢包和协调者发生异常，导致一部分参与者收到了PreCommit请求，另一部分没收到PreCommit请求。因为超时机制，没收到的会执行Abort，而收到的在等待三阶段的Commit超时后，会自动提交，从而造成整个协议的不正确。（心跳机制解决）

## 二阶段提交协议在Seata中的应用

Seata是一款解决微服务架构的分布式事务的框架。提供多种事务模式，XA模式，TCC模式，Saga模式，AT模式。

在Seata的架构设计中主要存在三个角色，即事务管理者、资源管理者、事务协调者。

- 事务管理者（TM）：负责驱动事务协调者（TC）执行全局事务的开启、提交和回滚操作，其通常由发起全局事务的业务服务充当。

- 资源管理者（RM）：按照事务协调者（TC）的指令，执行分支事务的提交或回滚，并向事务协调者汇报分支事物的状态。其一般由全局事务中涉及的所有下游服务充当。

- 事务协调者（TC）：维护全局事务的状态，执行全局事务的提交和回滚操作，驱动资源管理者（RM）执行分支事物的提交或者回滚，由Seata-Server充当。

### AT模式

AT模式由二阶段协议演变而来。也分为两个阶段，实现多个分支事务之间的原子提交。与二阶段不同的是，AT模式缩小了分支事务资源的锁定范围。

#### 1. 第一阶段

AT模式在第一阶段的任务执行完后，会释放分支事务资源，不需要像二阶段提交协议一样，要等到整个协议完成协商之后才能释放资源，具体逻辑如下：

第一阶段，TM向TC注册全局事务，TC会为本次全局事务生成唯一的XID并返回给TM，后续TM与RM交互的请求都会携带XID。当RM收到TM执行的指令后 ，需要现货的本地所才能执行分支事务并记录Undo的Redo日志。RM根据Undo日志所涉及的数据向TC申请该数据的全局锁，在获得全局锁后，RM会提交本地事务并释放本地锁。最后RM向TC和TM上报分支事务执行的状态，完成第一阶段的工作。

![](.\图片\AT模式第一阶段.jpg)

#### 2. 第二阶段

第二阶段，在TM调用RM的过程中，如果存在一个或多个RM处理发生异常的情况，则TM将向TC发送Rollback指令，TC将向RM发送Rollback指令，在等待所有RM反馈之后，删除全局事务，释放资源锁。

在RM收到回滚指令后，RM依然拥有事务数据的全局锁，但没有本地锁，因此RM需要重新获得本地锁，然后根据第一阶段记录的Undo日志对数据进行恢复。提交重做食物后，释放本地锁。最后RM向TC上报分支事务状态，TC释放全局锁，完成本次回滚。![](.\图片\AT模式第二阶段.jpg)

问题：为什么RM在执行Rollback的时候，拥有全局锁，却还要本地锁呢?

在第二阶段，另外一种情况就是提交全局事务。在TM调用RM的过程中，如果所有RM都正常完成工作，那么TM向TC发送提交指令，TC收到提交指令后，会立即向TM反馈成功的响应，然后异步处理提交指令。在处理提交操作中，TC向RM发送Commit指令并删除全局事务，释放全局锁。

相比Rollback指令来说，Commit指令对RM的工作要简单许多。由于第一阶段各个分支事务都已经完成提交，因此第二阶段的Commit指令RM只需要删除Undo日志即可。

![](.\图片\AT模式第二阶段Commit.jpg)

为了提高效率RM收到Commit指令后，实时反馈成功，TC立即释放全局锁，RM则在异步线程处理Commit指令。由于RM秩序删除Undo日志即可，所以该阶段即使发生故障也没有关系，不会影响其他事务的处理。在实际情况中Seata采用的是批量删除，以减少与数据库交互的次数。

#### 3. AT模式与二阶段提交协议的区别

AT模式缩小了分支事务资源锁定的范围。虽然AT模式提高了系统的工作效率，但复杂度也相对提高了，由于AT模式第一阶段就提交了分支事务，因此在第二阶段也需要相应变化，具体总结如下：

1. 第一阶段提交分支事务，释放本地锁和事务资源，以提高系统工作效率。

2. 增加Undo日志，用于第二阶段的回滚。

3. 第二阶段提交异步化，进一步提高了正常工作的协商效率。

4. 第二阶段回滚操作需要根据Undo日志，对第一阶段已提交的事务进行反向补偿。

### 事务管理者

Seata1.3.0 ，以电商平台的下单为例，提供3个服务：Order、Account和Storage。用户调用Order进行下单，Order服务分别调用Account服务进行扣款，调用Storage服务来减少商品库存，然后在自己的数据库中记录订单信息。如图

![](.\图片\订单处理逻辑.jpg)
