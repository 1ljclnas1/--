# 1. 进程、线程、协程的区别与联系

**进程：** 进程是操作系统进行资源分配和调度的基本单位，是一个独立运行的程序实体。每个进程拥有独立的内存空间、文件描述符、寄存器状态等资源。进程之间的资源是相互隔离的，因此进程间通信需要通过操作系统提供的特定机制（管道、消息队列、共享内存等）进行。由于进程拥有独立的资源，所以进程间的切换与调度开销较大。

**线程：** 操作系统调度执行的最小单位，是进程内的一个执行流。一个进程可以拥有多个线程，这些线程共享进程的资源。由于线程共享相同的资源，通信相对简单，可以直接通过共享变量、锁等方式进行。上下文切换和调度开销较小。但多个线程并发的时候要处理好同步和互斥问题，以避免数据不一致或竞争条件

**协程：** 一种用户态的轻量级线程，它的调度和切换完全由程序控制，不依赖于操作系统的调度。写成之间共享线程的资源，因此协程间通信也可以通过共享变量、锁等方式进行。写成的优势在于能够轻松地实现高并发没适用于IO密集型任务，通过异步IO可以有效地提高程序的性能。

# 2. 讲一讲用户线程与内核线程****

**用户线程：** 完全在用户空间中实现和管理的线程。他们的创建、同步和调度由用户级别的线程库处理，不需要内核直接参与、由于不涉及系统调用，他们的创建和切换开销相对较小。用户线程的一个主要限制是，它们不能充分利用多核处理器的并行能力。因为操作系用调度的基本单位是内核线程，当一个用户线程阻塞时（IO），这个进程都会被阻塞，即使其他用户线程仍处于就绪状态。这可能导致多处理器系统性能下降。

**内核线程：** 内核线程是由操作系统内核直接支持和管理的线程。内核负责创建、调度和销毁内核线程，每个内核线程都拥有独立的内核栈和线程上下文。由于内核线程是操作系统调度的基本单位，他们可以充分利用多处理器系统的并行能力。缺点是，创建、切换和同步操作涉及系统调用，导致较大的开销。此外需要更多的内核资源，这可能在大量线程的情况下导致资源耗尽。

**总结：** 两种线程实现方式，用户线程开销较小，可能无法充分利用并行能力；内核线程充分利用多处理器的并行能力，但开销大。Linux上采用了混合模型，将用户线程和内核线程结合起来。在这种模型中，每个用户线程都映射到一个内核线程上，这样可以同时利用用户线程的轻量级特性和内核线程的并行能力。

# 3. 一个进程可以创建多少个线程

受多种因素影响，包括操作系统的限制、系统资源（内存、CPU）的可用性和程序的设计要求。

- 操作系统限制：不同操作系统和平台对每个进程可以创建的线程数量有不同的限制，/proc/sys/kernel/threads-max文件获取系统级别的最大线程数限制。此外可以使用ulimit限制每个进程的线程数限制

- 系统资源：受可用内存和CPU资源限制。每个线程都需要一定的内存来存储线程栈和其他线程相关的数据结构。如果系统内存不足，可能无法创建更多线程。同样，系统的CPU资源也会影响，线程数太多会降低性能。

- 程序设计要求。

# 4. 进程的调度算法

## 时间片轮转

## 优先级调度

## 先到先得FCFS

## 最短任务优先

## 最短完成时间优先

## 多级队列

## 多级反馈队列

# 5. 进程间的通信方式

## 管道

- 单向IPC，内核中存在一定缓冲区，并且传输的数据是字节流。管道在UNIX中是被当作一个文件，系统调用会提供两个文件描述符供用户读写文件。

- 如果管道的写端没有被进程持有，而收端尝试去读的话，此时会收到EOF，如果写端有进程持有，读端就会阻塞在read上

- 分为命名管道与匿名管道，匿名进程用于有亲缘关系的两个进程之间

- 命名管道可以用于无亲缘关系的两个进程

- 管道只能单向传输，想双向传输，就用socketpair会创建两个socket。

## 消息队列

- 唯一一个以消息为数据抽象的通信方式，是一个单链表构成的队列，最初有一个消息头部指针，保存队首与权限；每个消息有下一个消息的指针以及本身的内容。

- 内存空间有限，传递长消息时采用共享内存的方式，而非消息队列。消息队列传递数据需要先copy到内核，然后再到收端，有代价。

## 信号量

- 辅助控制多个线程访问有限数量资源的

- 主要用于同步，两个原子操作P、V

## 共享内存

- 共享内存不需要先拷贝到内核空间，速度比较快，共享内存的核心思想就是允许一个或者多个进程所在的虚拟地址空间中映射相同的物理页，从而进行通信

- 首先内核会给全局的共享内存维护一个全局的队列结构，这个队列的每一项是一个shmid_kernel结构体与一个IPC key来绑定的，各进程可以通过key来找到并使用同一段共享你内存；该进程能否操作这段共享内存时System V权限检查机制来判断。

- 当两个进程同时对一个共享你内存建立了映射后，内核会给它们分配两个VMA结构体，进程可以通过它们各自的虚拟地址来访问VMA并访问背后的共享内存。

![](图片\共享你内存.png)

# 6. 进程虚拟化

允许多个进程在同一个计算机上运行，同时为每个进程提供独立的虚拟地址空间和资源。进程虚拟化的目标是提高资源利用率、隔离进程以保证系统安全性和稳定性，以及简化进程管理和调度。

- **虚拟地址空间：** 在进程虚拟化中，每个进程都有自己的虚拟地址空间，与其他进程的地址空间相互独立。虚拟地址空间包含了进程的代码、数据、堆和栈等内存区域。虚拟地址空间通过内存管理单元（MMU）映射到物理内存，实现了虚拟内存的概念。这种映射使得每个进程都认为自己在独占整个地址空间，从而简化了内存管理和保护。

- **上下文切换：** 在进程虚拟化中，操作系统需要在不同的进程之间进行切换，以实现多任务和并发。上下文切换是指保存当前进程的状态（寄存器、程序计数器、内存映射等），然后恢复另一个进程的状态，从而实现进程切换。上下文切换可能导致一定的性能开销，因此需要在进程调度和同步中尽量减少不必要的切换。

- **进程隔离：** 进程虚拟化提供了一定程度的进程隔离，以确保一个进程的错误或恶意行为不会影响其他进程和系统。进程隔离通过虚拟地址空间、内存保护和权限控制等机制实现。例如，一个进程无法直接访问另一个进程的内存，除非通过进程间通信或共享你内存的方式。此外，操作系统还可以限制进程对文件、设备和网络等资源的访问。

- **进程调度：** 在进程虚拟化中，操作系统负责根据优先级、资源需求和策略等因素调度进程的执行。进程调度一再提高资源利用率，降低响应时间和确保公平性。

# 7. 进程的状态有哪些

![](图片\进程状态.jpg)

- **新建：** 当一个进程刚刚被创建时，它处于新建状态。这个状态下，操作系统为进程分配必要的资源，如内存、文件描述符等，并初始化进程控制块（PCB）等数据结构。

- **就绪：** 进程已经准备好运行，正在等待操作系统调度器分配CPU时间片。就绪状态的进程已分配到了除CPU之外的所有必要资源，只需要CPU时间片就可以开始执行。

- **运行：** 进程正在CPU上执行。在任何给定时刻，每个CPU或核心上最多只能有一个进程处于运行状态。

- **阻塞：** 进程因等待某个事件（IO、锁、信号）而暂停执行。

- **终止：** 完成执行或因某种原因被终止。进程资源被回收，PCB可能保留一段时间一边父进程获取子进程的退出状态。

# 8. 进程如何创建的

Linux下：

1. **调用fork()系统调用：** 通常从一个已有的进程开始。fork()系统调用会复制父进程的PCB、虚拟内存布局、文件描述符等数据结构，从而创建一个与父进程几乎完全相同的子进程。

2. **子进程修改内存映射：** 在fork()之后，子进程通常需要修改器虚拟内存映射，以实现写时复制机制。写时复制是一种内存优化技术，它允许子进程在创建时共享父进程的内存页面，直到修改页面内容时才复制页面。避免了不必要的内存复制。

3. **调用exec()系统调用（可选）：** 如果子进程需要执行与父进程不同的程序，可以调用exec()系统调用来替换当前的程序映像。exec会加载新程序的代码和数据到内存，然后设置程序计数器指向寻程序的入口点。需要注意，exec()会替换子进程的程序映像，但不会影响进程控制块PCB、文件描述符等数据结构。

4. **子进程开始执行：** 子进程开始执行或继续执行父进程代码。通常根据fork或exec的返回值来判断自己的角色，并执行相应的逻辑。例如，子进程可能会关闭不需要的文件描述符、初始化资源或启动新的线程等

5. **父进程等待子进程（可选）：** 父进程可以等待子进程结束，以获取子进程退出状态和回收资源。

# 9. 如何回收线程

- C++11中使用join()方法

- 使用detach线程分离，确保线程退出时自动回收资源。

- 使用线程局部存储，确保线程退出时自动回收其占用的资源，从而简化线程管理和资源回收。

# 10. 进程终止方式

是指一个进程完成其生命周期并释放占用资源的过程

- **正常终止：** 进程自然完成并退出。通常返回一个退出状态码，以表示执行结果

- **异常终止：** 进程因某种错误或异常而被迫退出的情况

- **通过信号终止：** 使用Signal机制向进程发送事件和命令、部分可导致终止SIGTERM、SIGINT、SIGKILL

- **通过系统调用终止：** 进程调用exit、abort等主动终止自己

- **父进程终止子进程：** 父进程可以向子进程发送SIGTERM、SIGINT、SIGKILL等信号

# 11. 如何让进程后台运行

加一个&

可以使用nohup命令，会让进程忽略SIGHUP信号，使进程在终端关闭后不会关闭

```shell
nohup ./program &
```

# 12. 讲一讲守护进程，僵尸进程，孤儿进程

## 守护进程

一种在后台运行的特殊进程，通常用于提供某种服务或执行定期任务。没有控制终端，因此不会与用户交互。他们通常在系统启动时启动，并在系统关闭时终止。守护进程通常以d结尾

1. 调用fork产生子进程，然后父进程退出。

2. 调用setsid创建新的会话并成为绘画组长，以确保进程不再拥有终端。

3. 改变当前工作目录（例如，切换到根目录）

4. 重设文件权限掩码（umask）

5. 关闭不需要的文件描述符

6. 处理相关信号（SIGHUP、SIGTERM等）

## 僵尸进程

已经终止但仍占用进程表空间的进程，如果父进程没有调用wait或waitpid。

## 孤儿进程

父进程在子进程之前终止，子进程失去父进程被init收养，直至运行结束

# 13. 讲一讲父进程，子进程，进程组，会话

**父进程和子进程：** ...

**进程组：** 一个或多个进程的集合，共享相同的进程组ID。进程组用于组织具有相关任务的进程，并允许像整个进程组发送信号。进程组ID通常由进程组中的第一个进程的进程ID决定。可以调用setpgid加入一个进程组或创建一个新的进程组

**会话：** 一个或多个进程组的集合，共享相同的会话ID。会话用于管理终端和登录环境下的进程。每个会话有一个单独的控制终端。可以发送信号给会话中的所有进程。会话ID通常由会话中第一个进程的进程ID决定。可以调用setsid创建一个新的会话，并成为组长。

# 14. 多进程与多线程怎么选择

## 应用场景

- 多进程：需要独立的地址空间和资源，或需要在不同的安全上下文中运行

- 多线程：需要高度共享数据和资源，或需要轻量级的任务并发

## 资源需求

- 多进程：多进程资源占用更高

- 多线程：资源占用低

## 开发和维护难度

- 多进程：IPC较为复杂，创建和管理比较重

- 多线程：通信简单，设计复杂的同步和锁机制

## 可扩展性

- 多进程：更好的利用多喝处理器和分布式系统，有更好的可扩展性

- 多线程：

## 容错性和隔离

- 多进程：一个进程崩溃不太可能影响其他进程

- 多线程：一个线程崩溃，整个进程崩溃

# 15. 什么情况下，进程会进行切换

- 时间片到期

- 高优先级就绪

- 进程自愿让出

- 进程阻塞

- 中断处理

# 16. 进程通信中的管道实现原理是什么

1. **创建管道：** pipe返回两个文件描述符的整数数组，分别为写、读，内部使用内核缓冲区作为数据传输的临时存储。

2. **建立进程间关系：** 通常与fork一起用。子进程继承父进程的文件描述符，这样就可以通信。

3. **读写数据：** 使用普通的IO函数来读取和写入。

4. **关闭管道：** 关闭对应的文件描述符

# 17. 为什么进程切换慢，线程块

- 上下文切换的范围：进程切换时，需要保存和恢复更多的上下文信息，如寄存器状态、内存管理信息等。而线程仅需要保存和恢复线程特有的上下文信息，如寄存器状态、栈指针和程序计数器等。因为线程共享进程的地址空间和其他资源，所以操作系统不需要保存和恢复这些资源的状态

- 缓存效应：线程由于共享进程的地址空间和资源，因此CPU缓存命中率更高

- 资源同步：进程切换可能会设计更复杂的资源同步操作，如内存管理、文件描述符等。而线程切换由于共享资源，通常不需要进行这些同步
