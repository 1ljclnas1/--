# 1. select、poll、epoll的区别与联系

都是多路I/O复用技术、用于同时处理多个I/O操作。

## select

可以同时监听多个文件描述符的I/O状态（可读、可写、异常等）。使用一个文件描述符集合（通常是一个位图）来表示要监视的文件描述符，当有I/O事件发生时，select会返回对应的文件描述符集合。

select的限制：

- 数量限制，通常1024个

- 效率：数量较大时，因为它需要遍历来查找就绪的文件描述符，所以效率较低

- 非实时性：每次调用的时候，需要重新设置文件描述符集合，会增加函数调用的开销

## poll

为了克服select限制而引入的、poll使用一个文件描述符数组（通常是一个结构体数组）来表示要监视的文件描述符。

优点：

- 文件描述符数量不受限制

- 效率相对较高：只需要遍历实际使用的文件描述符数组，而不是整个集合

问题：

- 效率：当文件描述符数量很大的时候，仍然需要遍历整个文件描述符数组

- 非实时性：需要重新设置文件描述符数组

## epoll

使用一个事件驱动的方式处理I/O操作，只返回就绪的文件描述符，而不是遍历整个集合

优点：

- 高效：在处理大量文件描述符时具有很高的效率。

- 可扩展性：处理任意数量文件描述符

- 实时性：用一个内核事件记录要监视的文件描述符和事件。因为每次调用的时候无需重新设置文件描述符集合。

# 2. 边缘触发与条件触发分别是什么

## 边缘触发（Edge-triggered）

在事件状态发生变化的时刻触发一次，从无事件变为有事件。在I/O多路复用中，边缘触发意味着当某个文件描述符发生I/O事件（如变为可读或可写）时，只会收到一次通知。收到后，需要处理该文件描述符上的所有数据，直到全部处理完毕，否则不会再收到通知。

优点：只在事件状态改变时触发，可以减少事件通知的次数。

缺点：需要确保在收到通知后处理所有相关数据，否则可能会遗漏某些事件。

## 条件触发（Level-triggered）

只要事件状态保持满足某种条件，就会持续触发。在I/O多路复用中，条件出发意味着只要某个文件描述符的I/O事件状态满足条件，就会不断收到通知。

优点：确保不会遗漏

缺点：大量的事件通知，从而增加处理开销。

# 3. 讲一讲client-serverr通信双方API的调用过程

## 服务端

1. 创建套接字（socket）

2. 绑定地址（bind）

3. 监听连接（listen）

4. 接受连接（accept）

5. 接收数据（recv）

6. 发送数据（send）

7. 关闭连接（close）

## 客户端

1. 创建套接字（socket）

2. 连接服务器（connect）

3. 发送数据（send）

4. 接收数据（recv）

5. 关闭连接（close）

## 4. 阻塞IO、非阻塞IO有什么区别？怎么判断写文件时Buffer已经写满

主要区别在于IO操作是否会导致调用者等待

## 阻塞IO(Blocking IO)

阻塞模式下，如果数据没准备好，则调用者被阻塞，直到准备好。效率低

## 非阻塞IO

提高调用者的效率和资源利用率，适用于高并发场景。使用IO多路复用技术select、poll、epoll。

## 写文件Buffer是否写满

阻塞模式下，如果Buffer满了，调用者会被阻塞，直到Buffer有足够的空间容纳新的数据。这种情况下，会由操作系统处理，不用担心。

非阻塞下，如果Buffer满了，调用者会受到一个错误码，表示资源不可用。这种情况下需要根据错误码来判断Buffer是否已满，并在适当的时间点再次尝试写入，通常，可以结合IO多路复用技术监听文件描述符的可写事件，以便在Buffer有空间时得到通知。

# 5. 同步与异步的区别，阻塞与非阻塞的区别

同步和异步主要关注调用者与被调用者之间的关系

- 同步（synchronous）：在同步操作中，调用者发起请求后，等待被调用者处理完毕并返回结果，期间调用者不进行其他操作，串行。

- 异步(Asynchronous):调用者发起请求后，可以执行其他操作。被调用者处理完请求后，通过回调函数、事件或消息队列通知调用者结果。

阻塞非阻塞关注IO操作：

- 阻塞：如果数据被准备，就等数据准备好再进行操作

- 非阻塞：使用IO多路复用，当数据准备好之后，产生可读事件通知程序再进行处理，准据准备好之前，程序可以执行其他操作。

组合成为四种：

- 同步阻塞：在需要某资源时马上发起请求，并暂停本线程之后的程序，直至获得所需的资源。

- 同步非阻塞：在需要某资源时马上发起请求，且可以马上得到答复，然后继续执行之后的程序。但如果得到的不是完整的资源，之后将周期性地的请求，直至获得所需的资源。

- 异步阻塞：在需要某资源时不马上发起请求，而安排一个以后的时间再发起请求。当到了那时发出请求时，将暂停本线程之后的程序，直至获得所需的资源。在获取资源之后，使用共享信号量、异步回调等方式将结果异步反馈。

- 异步非阻塞：在需要某资源时不马上发起请求，而安排一个以后的时间再发起请求。当到了那时发出请求时，可以马上得到答复，然后继续执行之后的程序。但如果得到的不是完整的资源，之后将周期性地的请求。在最终获取到资源之后，使用共享信号量、异步回调等方式将结果异步反馈。

# 6. 讲一讲Reactor和Proactor模式

都是处理并发IO事件的设计模式。核心思想是将IO操作与时机处理逻辑解耦。

## Reactor模式

1. Reactor负责监视多个资源上的IO事件。当某个资源上发生IO事件时，Reactor将事件通知对应的事件处理器。

2. 事件处理器负责处理这些IO事件，如接受连接、读取数据、写入数据等。事件处理器将IO操作与实际的业务逻辑解耦，时程序易于管理和扩展

3. Reactor模式通常使用非阻塞的IO操作。当资源不可用时，事件处理器不会阻塞，而是返回并允许Reactor继续监视其他资源。

适用于IO密集型，特别是当IO操作可能导致阻塞时。

## Proactor模式

是Reactor模式的扩展，采用异步IO操作和操作系统级别的异步通知机制。

1. Propactor负责启动异步IO操作（如读取、写入）。异步IO操作在后台进行，不会阻塞主程序的执行

2. 当异步IO完成时，操作系统通知Proactor。Proactor随后调用相应的异步操作处理器来处理已完成的操作。

3. 异步操作处理器负责处理已完成的异步IO操作。与Reactor类似，这些处理器将IO操作与实际的业务逻辑解耦。

4. 充分利用了操作系统的异步IO功能，简化了并发IO处理。需要考虑跨平台兼容性。

# 7. 如何调试服务器内存占用过高的问题

可能是内存泄漏、程序逻辑错误等

1. **监控内存使用情况：** 首先使用top、htop、free等命令，实时监控服务器的内存使用情况。

2. **确定问题进程：** 接下来，通过监控工具找出内存占用过高的进程。并使用top或ps查看详细信息

3. **分析进程内存使用：** 使用pmap或smem等来查看进程的内存使用情况。了解内存分布，如栈、堆、共享库等

4. **分析内存泄漏：** 如果怀疑是内存泄漏，可以使用内存泄漏检测工具。

5. **分析程序代码：** 是否存在内存分配和释放不当、数据结构设计不合理等问题。

6. **优化程序：** 针对发现的问题，优化程序代码，修复内存泄漏和逻辑错误。修复后，重新监控

7. **定期检查**

# 8. Linux下如何查到端口被哪个进程占用
