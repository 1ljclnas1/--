# 1. select、poll、epoll的区别与联系

都是多路I/O复用技术、用于同时处理多个I/O操作。

## select

可以同时监听多个文件描述符的I/O状态（可读、可写、异常等）。使用一个文件描述符集合（通常是一个位图）来表示要监视的文件描述符，当有I/O事件发生时，select会返回对应的文件描述符集合。

select的限制：

- 数量限制，通常1024个

- 效率：数量较大时，因为它需要遍历来查找就绪的文件描述符，所以效率较低

- 非实时性：每次调用的时候，需要重新设置文件描述符集合，会增加函数调用的开销

## poll

为了克服select限制而引入的、poll使用一个文件描述符数组（通常是一个结构体数组）来表示要监视的文件描述符。

优点：

- 文件描述符数量不受限制

- 效率相对较高：只需要遍历实际使用的文件描述符数组，而不是整个集合

问题：

- 效率：当文件描述符数量很大的时候，仍然需要遍历整个文件描述符数组

- 非实时性：需要重新设置文件描述符数组

## epoll

使用一个事件驱动的方式处理I/O操作，只返回就绪的文件描述符，而不是遍历整个集合

优点：

- 高效：在处理大量文件描述符时具有很高的效率。

- 可扩展性：处理任意数量文件描述符

- 实时性：用一个内核事件记录要监视的文件描述符和事件。因为每次调用的时候无需重新设置文件描述符集合。

# 2. 边缘触发与条件触发分别是什么

## 边缘触发（Edge-triggered）

在事件状态发生变化的时刻触发一次，从无事件变为有事件。在I/O多路复用中，边缘触发意味着当某个文件描述符发生I/O事件（如变为可读或可写）时，只会收到一次通知。收到后，需要处理该文件描述符上的所有数据，直到全部处理完毕，否则不会再收到通知。

优点：只在事件状态改变时触发，可以减少事件通知的次数。

缺点：需要确保在收到通知后处理所有相关数据，否则可能会遗漏某些事件。

## 条件触发（Level-triggered）

只要事件状态保持满足某种条件，就会持续触发。在I/O多路复用中，条件出发意味着只要某个文件描述符的I/O事件状态满足条件，就会不断收到通知。

优点：确保不会遗漏

缺点：大量的事件通知，从而增加处理开销。

# 3. 讲一讲client-serverr通信双方API的调用过程

## 服务端

1. 创建套接字（socket）

2. 绑定地址（bind）

3. 监听连接（listen）

4. 接受连接（accept）

5. 接收数据（recv）

6. 发送数据（send）

7. 关闭连接（close）

## 客户端

1. 创建套接字（socket）

2. 连接服务器（connect）

3. 发送数据（send）

4. 接收数据（recv）

5. 关闭连接（close）

# 4. 阻塞IO、非阻塞IO有什么区别？怎么判断写文件时Buffer已经写满

主要区别在于IO操作是否会导致调用者等待

## 阻塞IO(Blocking IO)

阻塞模式下，如果数据没准备好，则调用者被阻塞，直到准备好。效率低

## 非阻塞IO

提高调用者的效率和资源利用率，适用于高并发场景。使用IO多路复用技术select、poll、epoll。

## 写文件Buffer是否写满

阻塞模式下，如果Buffer满了，调用者会被阻塞，直到Buffer有足够的空间容纳新的数据。这种情况下，会由操作系统处理，不用担心。

非阻塞下，如果Buffer满了，调用者会受到一个错误码，表示资源不可用。这种情况下需要根据错误码来判断Buffer是否已满，并在适当的时间点再次尝试写入，通常，可以结合IO多路复用技术监听文件描述符的可写事件，以便在Buffer有空间时得到通知。

# 5. 同步与异步的区别，阻塞与非阻塞的区别

同步和异步主要关注调用者与被调用者之间的关系

- 同步（synchronous）：在同步操作中，调用者发起请求后，等待被调用者处理完毕并返回结果，期间调用者不进行其他操作，串行。

- 异步(Asynchronous):调用者发起请求后，可以执行其他操作。被调用者处理完请求后，通过回调函数、事件或消息队列通知调用者结果。

阻塞非阻塞关注IO操作：

- 阻塞：如果数据被准备，就等数据准备好再进行操作

- 非阻塞：使用IO多路复用，当数据准备好之后，产生可读事件通知程序再进行处理，准据准备好之前，程序可以执行其他操作。

组合成为四种：

- 同步阻塞：在需要某资源时马上发起请求，并暂停本线程之后的程序，直至获得所需的资源。

- 同步非阻塞：在需要某资源时马上发起请求，且可以马上得到答复，然后继续执行之后的程序。但如果得到的不是完整的资源，之后将周期性地的请求，直至获得所需的资源。

- 异步阻塞：在需要某资源时不马上发起请求，而安排一个以后的时间再发起请求。当到了那时发出请求时，将暂停本线程之后的程序，直至获得所需的资源。在获取资源之后，使用共享信号量、异步回调等方式将结果异步反馈。

- 异步非阻塞：在需要某资源时不马上发起请求，而安排一个以后的时间再发起请求。当到了那时发出请求时，可以马上得到答复，然后继续执行之后的程序。但如果得到的不是完整的资源，之后将周期性地的请求。在最终获取到资源之后，使用共享信号量、异步回调等方式将结果异步反馈。

# 6. 讲一讲Reactor和Proactor模式

都是处理并发IO事件的设计模式。核心思想是将IO操作与时机处理逻辑解耦。

## Reactor模式

1. Reactor负责监视多个资源上的IO事件。当某个资源上发生IO事件时，Reactor将事件通知对应的事件处理器。

2. 事件处理器负责处理这些IO事件，如接受连接、读取数据、写入数据等。事件处理器将IO操作与实际的业务逻辑解耦，时程序易于管理和扩展

3. Reactor模式通常使用非阻塞的IO操作。当资源不可用时，事件处理器不会阻塞，而是返回并允许Reactor继续监视其他资源。

适用于IO密集型，特别是当IO操作可能导致阻塞时。

## Proactor模式

是Reactor模式的扩展，采用异步IO操作和操作系统级别的异步通知机制。

1. Propactor负责启动异步IO操作（如读取、写入）。异步IO操作在后台进行，不会阻塞主程序的执行

2. 当异步IO完成时，操作系统通知Proactor。Proactor随后调用相应的异步操作处理器来处理已完成的操作。

3. 异步操作处理器负责处理已完成的异步IO操作。与Reactor类似，这些处理器将IO操作与实际的业务逻辑解耦。

4. 充分利用了操作系统的异步IO功能，简化了并发IO处理。需要考虑跨平台兼容性。

# 7. 如何调试服务器内存占用过高的问题

可能是内存泄漏、程序逻辑错误等

1. **监控内存使用情况：** 首先使用top、htop、free等命令，实时监控服务器的内存使用情况。

2. **确定问题进程：** 接下来，通过监控工具找出内存占用过高的进程。并使用top或ps查看详细信息

3. **分析进程内存使用：** 使用pmap或smem等来查看进程的内存使用情况。了解内存分布，如栈、堆、共享库等

4. **分析内存泄漏：** 如果怀疑是内存泄漏，可以使用内存泄漏检测工具。

5. **分析程序代码：** 是否存在内存分配和释放不当、数据结构设计不合理等问题。

6. **优化程序：** 针对发现的问题，优化程序代码，修复内存泄漏和逻辑错误。修复后，重新监控

7. **定期检查**

# 8. Linux下如何查到端口被哪个进程占用

1. lsof -i 端口号

2. netstat -tunlp | p | grep 端口号

# 9. Linux零拷贝原理

传统IO如下

![](C:\Users\ljc\Documents\GitHub\--\操作系统\图片\传统IO.jpg)

零拷贝就是避免CPU将数据从一块存储拷贝到另一块存储的技术。通过减少用户态与内核态上下文切换和减少内存拷贝次数实现，通常实现方式有三种：mmap+write、sendfile、sendfile+DMA scatter/grather

- mmap+write：mmap()会直接把内核缓冲区里的数据映射到用户空间，这样，操作系统内核与用户空间就不需要在进行任何的数据拷贝操作。包含2次系统调用，3次数据拷贝（2次DMA和1次CPU拷贝）
  
  1. 用户进程通过mmap方法向操作系统内核发起IO调用，上下文从用户态切换为内核态
  
  2. CPU利用DMA控制器，把数据从硬盘中拷贝到内核缓冲区。
  
  3. **上下文从内核态切换回用户态**， mmap方法返回
  
  4. 用户进程通过write方法向操作系统内核发起IO调用，**上下文从用户态切换为内核态**。
  
  5. CPU将内核缓冲区数据拷贝到socket缓冲区。
  
  6. CPU利用DMA控制器，吧数据从socket拷贝到网卡，**上下文从内核态切换回用户态**，write调用返回。
  
  ![](C:\Users\ljc\Documents\GitHub\--\操作系统\图片\mmap+write.jpg)

- sendfile

可以代替read和write两个系统调用，减少一次系统调用。包含1次系统调用，三次数据拷贝（2次DMA1次CPU拷贝）

1. 用户进程发起sendfile系统调用，上下文（切换1）从用户态转为内核态。

2. DMA控制器，把数据从硬盘拷贝到内核缓冲区。

3. CPU将都缓冲区中数据拷贝到socket缓冲区

4. DMA控制器，异步把数据从socket缓冲区拷贝到网卡

5. 上下文（切换2）从内核态切换回用户态，sendfile返回

![](C:\Users\ljc\Documents\GitHub\--\操作系统\图片\sendfile.jpg)

- sendfile + DMA scatter/gather
  
  对sendfile进行升级，引入SG-DMA技术，其实就是对DMA拷贝加入了scatter/gather操作，可以直接从内核空间缓冲区中将数据读到网卡。使用这个特点搞零拷贝可以多省去一次CPU拷贝。包含1次系统调用，2次从数据拷贝
  
  1. 用户进程发起sendfile系统调用，上下文从用户态切换为内核态
  
  2. DMA控制器，把数据从硬盘中拷贝到内核缓冲区
  
  3. CPU把内核缓冲区中的文件描述符信息发送到socket缓冲区
  
  4. DMA控制器根据描述符信息，直接把数据从内核缓冲区拷贝到网卡
  
  5. 上下文切换回用户态，sendfile返回

![](C:\Users\ljc\Documents\GitHub\--\操作系统\图片\sendfile+DMA%20scatter_gather.jpg)

# 10. LVS的NAT、TUN、DR原理与区别

LVS是Linux Virtual Server的缩写，即linux虚拟服务器，是一个虚拟的服务器集群系统，使用负载均衡技术将多台服务器组成一个虚拟服务器。虚拟服务器的体系结构由一组通过高速的局域网或者地理分布的广域网相互连接，在他们的前端有一个负载调度器。负载调度器能无缝地将网络请求调度到真是服务器上。

## NAT（网络地址转换模式）

原理：把客户端发来的数据包的IP头的目的地址，在负载均衡器上转换成其中一台RS的IP地址，并发至此RS来处理，RS处理完成后把数据交给经过负载均衡器，负载均衡器再把数据包的原IP改为自己的IP，将目的地址改为客户端IP地址即可。

![](C:\Users\ljc\Documents\GitHub\--\操作系统\图片\LVS_NAT.jpg)

## TUN(IP隧道模式)

原理：把客户端发来的数据包，封装成一个新的IP头标记（仅目的IP）发给RS，RS收到后，先把数据包的头解开，还原数据包，处理后，直接返回给客户端，不需要在经过负载均衡器。注意，由于RS需要对负载均衡器发过来的数据包进行还原，所以说必须支持IPTUNNEL协议，所以，在RS的内核中，必须编译支持IPTUNNEL这个选项。

个集群节点可以跨越不同的网络，不用在同一个VLAN

调度器根据各个服务器的负载情况，动态地选择一台服务器，将请求保温封装在另一个IP报文中，再将封装后的IP保温转发给选出的服务器。

服务器收到报文后，先将保温解封获得原来目标地址为VIP的保温，服务器发现VIP地址被配置在本地的IP隧道设备上，所以就处理这个请求，然后根据路由表将响应报文直接返回给客户。

![](C:\Users\ljc\Documents\GitHub\--\操作系统\图片\LVS_TUN.jpg)

## DR（直接路由模式）

原理：负载均衡器和RS都使用同一个IP对外服务，但只有DR对ARP请求进行响应，所有RS对本身这个IP的ARP请求保持静默，也就是说网管会把对这个服务IP的请求全部定向给DR，而DR收到数据包后根据调度算法，找出对应的RS，把目的MAC地址改为RS的MAC地址并将请求分发给这个RS，这时RS收到这个数据包，处理完成之后，由于IP一致，可以直接将数据返回给客户，则与直接从客户端收到这个数据包无异，处理后直接返回给客户端。由于负载均衡器要对二层包头进行改换，所以负载均衡器和RS之间必须在一个广播域，也可以简单地理解为在同一台交换机上。

**区别：**

|     | 优点                                                                                                                            | 缺点                                                                                                    |
| --- | ----------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------- |
| NAT | 集群中的物理服务器可以使用任何支持TCP/IP操作系统它只需要一个 IP 地址配置在调度器上，服务器组可以用私有的 IP 地址                                                               | 扩展性有限。当服务器节点(普通PC服务器)增长过多时,负载均衡器将成为整个系统的瓶颈，因为所有的请求包和应答包的流向都经过负载均衡器。当服务器节点过多时，大量的数据包都交汇在负载均衡器那，速度就会变慢。 |
| TUN | 负载均衡器只负责将请求包分发给后端节点服务器，而RS将应答包直接发给用户。所以，减少了负载均衡器的大量数据流动，负载均衡器不再是系统的瓶颈，就能处理很巨大的请求量，这种方式，一台负载均衡器能够为很多RS进行分发。而且跑在公网上就能进行不同地域的分发。 | 隧道模式的RS节点需要合法IP，这种方式需要所有的服务器支持”IP Tunneling”(IP Encapsulation)协议，服务器可能只局限在部分Linux系统上。                 |
| DR  | VS/DR跟 VS/TUN 方法相同，负载调度器中只负责调度请求，而服务器直接将响应返回给客户，可以极大地提高整个集群系统的吞吐量。                                                            | 要求负载均衡器的网卡必须与物理网卡在一个物理段上                                                                              |

|        | NAT模式                  | IP TUN模式                        | DR模式                            |
| ------ | ---------------------- | ------------------------------- | ------------------------------- |
| 对服务器要求 | 任何操作系统均支持              | 必须支持IP隧道协议，目前只有Linux支持          | 支持虚拟网卡，且可以禁用ARP响应               |
| 网络要求   | 局域网                    | 局域网或广域网                         | 局域网                             |
| 支持的节点数 | 10~20个，视Director处理能力而定 | 可以支持到100个节点                     | 可以支持到100个节点                     |
| 安全性    | 较高，可隐藏real server      | 较差，real server 容易暴露             | 较差，real server 容易暴露             |
| IP要求   | 仅需要一个合法IP地址作为VIP       | 除VIP外，每个服务器需要拥有合法IP地址可以直接路由至客户端 | 除VIP外，每个服务器需要拥有合法IP地址可以直接路由至客户端 |
| 拓展性    | 差                      | 很好                              | 好                               |
| 特点     | 地址转换                   | 封装IP                            | 修改MAC地址                         |
