# 实现原理

## 1. init()函数什么时候执行的

是Go程序初始化的一部分，先于main函数，有runtime初始化每个导入的包，初始化顺序不是按照从上到下，而是按照解析的依赖关系，没有依赖的包最先初始化

## 2. Go语言的局部变量分配在栈上还是堆上

 由编译器决定，编译器会做逃逸分析，当变量的作用域没有超出函数范围的时候，就可以在栈上，不然必须在堆上

## 3. 2个interface可以比较么？

可以 使用 == != 比较

比较的时候比较类型T和值V。

## 4. 两个nil可能不相等么？

可能，接口时是堆非接口值的封装，内部实现包含两个字段T和V。一个结构等于nil仅当T和V处于unset状态（T=nil，V is unset）。

两个接口值比较会先比较T在比较V

接口值和非接口值比较时，会先将非接口值尝试转换为接口值再比较。

不相等的情况就是T不为nil但是V是unset，这个时候接口值与相应T类型的nil值比较为true，但是直接跟nil比就是false

## 5. 简述GC工作原理

最常见的垃圾回收算法有标记清除和引用计数。Go采用的是标记清除算法。并在此基础上使用了三色标记法和写屏障技术，用来提高效率

标记清除收集器是跟踪式垃圾收集器，起执行过程可以分成标记(Mark)和清除（Sweep）两个阶段：

- 标记阶段--从跟对象出发查找并标记堆中所有存活的对象；

- 清除阶段--遍历堆中的全部对象，回收违背标记的垃圾对象并将回收的内存加入空闲链表。

标记清除算法的一大问题是在标记期间需要STW。为了能够异步执行，减少STW的时间，采用了三色标记法

将程序中的对象分为3类：白色，灰色、黑色

- 白色：不确定对象

- 灰色：存活对象，子对象待处理

- 黑色：存活对象

标记开始时将所有对象加入白色集合（需要STW）。首先将根对象标记为灰色，加入灰色集合，垃圾收集器取出一个灰色对象，将其标记为黑色，并将其指向的对象标记为灰色，加入灰色集合，直至所有灰色对象被处理完，灰色集合为空。这是的白色对象就是不可达对象，需要被清理

因为三色标记法多了一个白色状态来存放不确定对象，uoyi后续的标记阶段可以并发的执行。但是并发的代价就是可能会造成一些遗漏，因为早先那些被标记为黑色的可能是不可达的了。所以它是一个false negative算法

但是三色标记法仍然存在一个问题就是如果在GC过程中，对象指针发生了改变，比如
A(黑)->B(灰)->C(白)->D(白)

正常情况下D应该被标记为黑色，不被回收。但是在标记和用户程序并发执行过程中，用户程序删除了C对D的引用，而A获得了D的引用。标记继续进行，这个时候D就没有机会被标记为黑色（A被处理过，这一轮不会再被处理）

为了解决这个问题，Go语言使用了内存屏障技术，他是在用户程序读取对象、创建新对象以及更新对象指针时执行的一段代码，类似于一个钩子。当对象新增或者更新的时候，将其着色为灰色。这样即使与用户程序并发执行，对象的引用发生改变时，垃圾收集器也能正确处理了。

一次完整的GC分为四个阶段：

- 标记准备（Mark Setup需要STW），打开写屏障

- 使用三色标记法标记（Marking，并发）

- 标记结束（Mark Termination，需STW），关闭写屏障

- 清理（Sweeping，并发）

## 6. 函数返回局部变量的指针是否安全？

这在Go中是安全的，Go编译器将会对每个局部变量进行逃逸分析。如果发现局部变量的作用域超出该函数，就不会分配在栈上，而是分配在堆上。

## 7. 非接口的任意类型T()都能够调用*T的方法么？反过来呢？

- 一个T类型的值可以调用为\*T类型声明的方法，但是仅当此T的值是可寻址的情况下。编译器在调用指针属主方法前们会自动取此T值的地址。因为不是任何T值都是可寻址的，所以并非任何T值都能够调用为类型\*T声明的方法

- 反过来，一个\*T类型的值可以调用为类型T声明的方法。

哪些值不可寻址？

- 字符串中的字节

- map对象中的元素

- 常量

- 包级别的函数
