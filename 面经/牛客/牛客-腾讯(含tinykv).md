# 牛客

## 腾讯 （含tinykv）

### 一面

#### 1. 简单讲tinykv

是整个talent plan项目的一个部分，是存储后端，整个项目还有TinySQL（解析）和TinyScheduler（中央调度，集群管理，TSO）两个组件。

在TinyKV中，分为三层最上层是server层，中间是storage层，底层是engine层使用的是badger。

server层主要是接收tinysql发送过来的读写请求（RPC调用），将其解析后交给存储层处理，存储层处理完成之后，封装成日志，在集群中同步，同步后写入底层engine。

对于数据划分使用关键字区间的方式划分为一个个的region，每一个region对应一个peer，由peer向底层edgine进行读写操作。共识的单位是region，对于一个region有一个raft group进行管理。一个node上可以有多个不同的region。

对于raft的实现并没有完全按照raft论文中的，进行全面实现，对于成员变更是一个一个进行的没有实现joint。

实现了multi raft，可以对多个不同region的数据进行并行处理。

#### 2. raft的工业改进

1. 并行协商：Multi Raft和Parallel Raft两种

Multi Raft就是将集群分为多个group，可以同时服务于多个业务系统

Parallel Raft是PolarFS基于Raft设计的新一代共识算法，支持真正的乱序协商。

乱序协商首先要打破Raft的一致性检查。重新制定Follower的检查约束，让Follower在接受日志项时不再受到上一个日志项的影响。显然打破了一致性检查之后，会导致日志出现空洞，随之而来的是无法保证新选举出来的领导者具有完整性。为了填补空白，新上任的leader需要相机群中其他成员收集对应的日志项（Merge阶段），当然这个Merge也打破了日志只由Leader流向follower的约束。

2. 联合共识

3. 日志压缩

4. 预选举 防止在网络分区的时候，某些Follower干扰正常工作的Leader

5. 异步的apply：当一个log被append之后，就可以认为是apply，因为无论什么时候apply都不会影响数据的一致性了，因此可以将apply交给异步线程去执行

6. 读写分离，不用将所有的Read都走一遍raft，可以在leader记录一个ReadIndex就是commit Index，这样Leader可以直接返回一部分的Read请求

7. Leader切换的优化：应该允许Leader主动将领导地位转移给其他成员，通常出于以下两点：
   
   1. leader必须下台。比如它不在Cnew的配置中，Leader需要定期维护或重启
   
   2. 其他成员更适合当选Leader比如离客户端更近。处理性能更好等。
   
   虽然让Leader强制关机，也能选出Leader，但是这中间的选举超时可以优化掉。只需要通知目标成员在不等待超时选举的情况下进入候选状态，并发起选举。为了使目标成员今生，需要保证目标成员拥有当前任期的所有日志项。所以流程如下：
   
   1. 当前leader停止服务，并通过AppendEntries消息将自己的日志复制给目标成员
   
   2. 当前Leader发起TimeoutNow给目标成员
   
   3. 目标成员收到后进入候选状态，并发起选举
   
   4. 目标成员晋升后，发送心跳给原leader，之后原leader可以下线了。

#### 3. 讲一下对raft的理解

raft做了以下事情：

问题分解：为了降低理解难度Raft将问题拆分为Leader选举、日志复制、安全性及成员变更

消除不确定性：要求所有的日志必须连续，不允许存在空洞。这样可以快速发现日志之间的差异，而不用像paxos一个一个的确认。另外，一切以Leader数据为依准，使得数据对齐简单

详细的细节实现：给出了详细的细节实现，比如超时的引入。

与paxos一样的是使用了多数派决策的思想。保证读写有交集。

raft将时间分割为不同的任期，记作term。以此可以发现一些过期的消息和过时的leader。

基础的raft算法定义了三个成员状态。而为了适应复杂的生产环境又引入了无投票权成员和Witness成员。前者用于成员上线的时候尽快赶上Leader的数据（当新成员加入的时候，由于数据不全，因此不能参与决策，防止阻断raft协商）；后者用于在不降低集群可用性的基础上降低部署成本，

Raft强化了Leader的地位，整个算法基于Leader分为两个阶段：leader选举和日志复制。

总的来说raft虽然通过强Leader模型、心跳机制和日志连续性，将协商过程优化为一个阶段，但不是说不包含其他阶段，而是说raft利用一些手段将这些额外的阶段变得没那么重要。对比Multi Paxos仍然可以划分为三个阶段：

第一个是Multi Paxos的Prepare阶段，对应Raft的Leader选举，因为Raft只有Leader进行推进，所以发起提案的权利一直由Leader霸占，而Multi Paxos允许其他的Proposer抢占发起提案的权利，由于可能的提案冲突，Prepare阶段的另一个作用是收集上一个Proposer可能发起的提案值。

第二个是Multi Paxos的Accept阶段，对应Raft的日志复制阶段，唯一的区别就是提案值的选择不同。

- 由于raft不存在提案冲突，可以由Leader任意指定提案值。

- Multi Paxos需要根据Prepare阶段的结果选取提案值。

第三个就是Multi Paxos的Confirm阶段，对应Raft的日志提交（通过下一次协商或者心跳消息来完成这个过程），而Multi Paxos需要一轮Confirm消息。

#### 4. 有没有了解过其他的共识算法

ZAB与PAXOS

#### 5.1 raft和paxos的区别

同：

都使用了多数派决策的思想，能友好地支持容错

不同：

1. Raft引入了强Leader模型，规避了Basic Paxos活锁的问题，Multi Paxos值降低了活锁的概率

2. 协商过程：Multi Paxos在大多数情况下可以优化为在一阶段内提交，但是达到一阶段提交的条件仍然是需要进入Prepare阶段，而Raft通过心跳机制代替了提交阶段。

3. 日志连续性：Paxos允许乱序提交，同样允许日志存在空洞。而Raft通过Leader严格规定了日志项的连续性。换句话说，Paxos只保证每个提案（日志项）达成共识的安全性，而Raft在此基础上保证了日志项的连续性，这一个特性就保证了在两个成员之间，相同日志索引且term相同，那么该日志想之前所有的日志项也必然相同。

4. 非事务请求：虽然Multi Paxos可以让Leader为每个提案（日志项）记录Confirm日志，但是对于未记录Confirm日志的提案，必须走一遍Paxos流程，才知道该提案是否已经达成共识。而Raft在日志连续的特性上，也要求了日志的提交顺序。因此Raft只需要明确commitedIndex，即可以推测在此之前的所有日志项都已达成共识。

5. 日志压缩：Paxos没剋有明确这个细节，但Paxos的工程实践中往往会采用Raft提到的快照方式进行日志压缩。

6. 日志存储：Paxos不要求每个成员都有完整的数据，而Raft要求成员再加入的时候先进行数据对齐。

7. 崩溃恢复：这一点在Paxos中没那么重要，每个成员具有对等性，成员崩溃后重启即可。而Raft成员崩溃后，再次加入的时候需要以Leader的数据为基准恢复数据，然后才可以加入集群。

#### 5.2 补充 raft与ZAB的区别

Raft与ZAB都引入了Leader这个角色，都通过心跳机制维护Leader的地位，协商只能由Leader发起和推进，但是有以下五点不同：

1. 当协商提案时，ZAB中的Follower会参与提案的决策，而在Raft中，Follower只会被动的接收日志项

2. 日志流向不同，在Raft中，日志只能由Leader流向Follower，而在ZAB中，当Leader晋升的时候，需要收集所有的Follower数据来生成Initial History

3. Leader选举不同。Raft引入了随机超时，降低了选举冲突的可能性，而ZAB通过增加成员ID来解决选举冲突的问题。Raft的每个成员在一个term上只能投一票，而ZAB的每个成员在一轮选举中可以投出多票

4. 上一任Leader的数据处理不同。Raft认为之前term不明确提交状态的日志都是未提交的，需要等待当前Leader提出新的日志项且达成共识后，才认为之前的日志项已提交。ZAB认为上一任Leader提出的不明确状态的日志都是已提交的，并且会将这些日志复制到其他成员中。

5. 在ZAB中，协商分为两个阶段，而Raft以心跳机制+日志连续的特性将协商优化为一个阶段。

#### 6. 操作系统的内存管理

远古动态分区法：很多内存碎片，没有进程地址空间保护，程序运行重定位

分段机制：增加了虚拟内存，保证了空间隔离解决了内存碎片的问题，但是会产生外部碎片，整段的换出导致大量磁盘访问。

分页机制：把段式分配的单位继续细分成固定大小的页面，进程的虚拟地址也按照页面来分割。分页机制需要硬件支持：MMU。包含TLB和页表遍历单元。

#### 7. linux的内存管理实现

##### 地址空间

首先，Intel在实现64位的CPU的时候，在64位寻址空间下只使用了48位有效寻址位数，低48位，用户空间最高位是0，1为内核空间（高地址）。

一个用户空间的程序主要包括了ELF部分和从内核申请的内存两部分，加载的ELF主要是ELF的segment段，一般有2-4个LOAD类型的segment，最后一个segment中包括.bss section,就是全0的内容。之后加载linker和so库。这些是通过mmap系统调用从内核中申请的。bss之后是brk内存段。

32位系统下最多可见4GB内存空间，3GB用户1GB内核。

内核只在用户程序真正使用内存的时候才给其分配内存，这是over_commit机制。

Linux内核会使用大量空间来缓存磁盘中的文件，几乎会用点所有可用的物理内存。当用户程序需要的时候Linux会回收一部分内存，用来满足用户需求。所以会有一个现象：看起来用户程序占用了大量的虚拟内存，但实际上都是内核在使用。

Linux的内存以页为单位，但是整体被组织为三个zone：DMA，Normal，High。

896MB的线性地址空间与真实物理内存地址是一一对应的即PAGE_OFFSET为0xC0000000；剩下的128MB就是高端内存，用来映射剩下的大于896MB的物理地址空间，即高端内存区。需要MMU通过TLB表建立动态映射关系。DMA对应0-16，Normal对应16-896，High对应896-1GB。

##### 寻址

硬件：Intel有四种寻址方式：32为寻址、PAE寻址、四级寻址、五级寻址，四级寻址就是使用48位，五级寻址使用57位。Linux和Intel四级寻址。五级寻址兼容四级寻址。

最高级的寻址表由CR3指向PML4(5),PDPT,PD,PT对应Linux的PGD,PUD,PMD,PT。5级对应的是PGD,P4D,PUD,PMD,PT。在硬件层面完成多级寻址的硬件模块就叫MMU。

软件：从高位到低位对应PGD,PUD,PMD,PT最后十二位11-0是页内偏移。指向第一级PGD表的内存地址存储在CR3中，ARM下是TTBR寄存器。

所有内核系统都是共享同样的内存空间的，只能看到内核空间的地址。

linux下进程的寻址数据结构：fork函数会调用mm_init函数初始化新创建的进程内存结构，其中调用mm_alloc_pgd()初始化第一级PGD表。

Intel硬件寻址过程：CR3的51-12位是PML4的绝对地址，不需要经过转换。PML4有512个元素，每个元素64位，所以PML4是正好4KB，40用于表示地址指向一个PDPT。一个PDPT代表512GB地址空间，PDPT有512个元素，每个条目的51-12（40位）指向PD，后12位为偏移表示PD的哪一个条目。这里注意，如果PDPTE的第七位即PS位是0的话，代表PDPT本身就是最后一级的页索引了（1GB大页）。选择一个PD就是选择了一个2MB的地址。与PDPT一样的方式支持大页（PS位为0）。最后一级的PT就是4KB地址空间。

页权限：第一位读写权限位，第二位区分内核页和用户页

页状态：第五位access表示被访问了，第六位dirty表示脏位（被改了）。

页缓存：首先说一下PCID，PCID是一个12位寄存器位于CR3上，代表一个进程ID。在进程上下文切换的时候由于MMU要求不同的进程使用不同组的页表来映射自己的用户空间内存，并共享一组相同的内核部分的页表映射，因此TLB中的进程页映射需要被清空（如果用了PCID就不用清空）。而清空TLB就代表，下次切换回来的时候TLB缓存要重新学习。有了PCID的时候那么每一条缓存都有一个进程ID，这样就不需要清空TLB了。

但是有很大的副作用，正常来说进程上下文切换的时候清空TLB就可以了，但是现在如果不清空的话，没有人刷TLB了，而进程又会在CPU核心之间调度，这样进程的页表项就会出现在很多CPU核心中，这个时候如果要更改页表属性或者删除页表，光干掉本身的CPU还不够，还有通过IPI的方式让别的CPU核心处理对应的页表项，而这个只能由CPU核心自己干，而且PCID长度有限，就需要进一步进行申请管理和放弃。

##### 堆内存管理

Buddy思想与slab思想

对于页的维度的申请使用buddy思想。一个buddy系统定义一个order概念，假设第0级order是64KB，有五级order就是64，128... 每个内存块进行切割的时候总是大小相等的，这样切割相当于外部碎片最少，但是有大量的内部碎片。

内部碎片使用slab思想。在buddy的基础上进一步切割成固定大小的块。（拟内存池）

只有互为伙伴的内存块才可以合并。

#### 8. 一个进程申请了一个内存，它的工作流程

#### 9. 内存分配器

#### 10. linux文件系统的实现

#### 11. C++虚函数是怎么实现的

虚函数是通过虚函数表来实现的，每个包含虚函数的类都被分配一个虚函数表，其中存储了该类的虚函数地址。

当类的对象被创建时，编译器将一个指向该类虚函数表的指针插入到对象的内存布局中即vptr。调用对象上的虚函数的时候，通过vptr找函数。

对于继承情况下的多态，派生类会继承基类的虚函数表，并覆盖其中的一些函数，当使用基类指针或引用来调用派生类的虚函数时，编译器会根据实际的对象类型，来找到对应的虚函数，这个就是动态绑定，也是运行时多态

#### 12. 空类大小是多少？为什么是1

一个字节，既是一个类没有任何的成员变量或成员函数，仍然要占用至少一个字节的内存空间。因为C++中，每个对象都应该有独一无二的地址，以区分不同对象。至少为1，有些可能会进行内存对齐。

#### 13. 字节对齐的概念，为什么要字节对齐

按照一定规则进行对其的概念。必须是特定字节数的倍数。

第一个是硬件要求，对于某些数据类型要求其地址必须按照特定方式对齐。不然可能性能下降甚至异常

第二个是性能优化：对其的内存可以更高效的处理数据，不然可能额外进行读取和处理。浪费CPU周期

第三个是缓存行优化，不对齐的话很容易造成跨多个缓存行边界，导致额外的缓存访问和性能下降。

#### 14. stl中的vector和map的实现原理

#### 15. 网络编程了解么？

#### 16. tcp四次挥手的流程

#### 17. time_wait在什么地方，有什么意义

#### 18. 服务器上如果有很多的time_wait怎么解决？

#### 19. 判断两条单链表是否相交

#### 20. 小白鼠毒药智力题

### 二面

#### 1. B+树和KV的区别

#### 2. Linux rc命令

#### 3. C++ sort实现

#### 4. raft和paxos的区别

#### 5. raft有什么优点

#### 6. raft有什么问题

#### 7. raft如何解决脑裂的问题

#### 8. raft leader性能问题

#### 9. 文件系统inode理解

#### 10. 内存管理是怎么做的

#### 11. stl内存分配器

#### 12. 内存不定长如何处理

#### 13. 开源内存池实现？

#### 14. 汇编了解过么？

#### 15. 虚函数理解？

#### 16. 多重继承，override

#### 17. 两个虚函数指针

#### 18. 5v5数据同步

## 三面

#### 1. c++程序内存分区

#### 2. 析构函数能不能是虚函数

#### 3. 构造函数能不能是虚函数

#### 4. 查看内存使用情况

#### 5. tcp拥塞控制机制

#### 6. 设计排行榜 时间复杂度O(logN) 空间复杂度O(N) QPS是多少。

#### 7. 职业规划
