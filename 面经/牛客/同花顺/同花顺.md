# 1. 智能指针

很多都是以下划线和大写字母开头

两大块unique_ptr 和 shared_ptr

unique_ptr是优先使用的，1倍的裸指针大小，

unique_ptr内存占用大小分析 ：

# 2. C++最新版本的新特点

1. 概念：概念是C++20的一个重要特性，它允许程序员定义一组类型要满足的规范或接口，并在编译时对这些规范进行检查。这可以帮助程序员编写更清晰、更具表现力的代码，并提高代码的可读性和可维护性。

2. 模块化编程：C++20引入了模块化编程的支持，允许开发者编写模块化的代码，而不是使用传统的头文件和源文件。这可以减少编译时间、避免对全局命名空间的污染，以及提高代码可移植性。

3. 协程：C++20中引入了协程，允许开发者以异步方式处理任务，而不需要使用回调函数或异步库。协程可以使异步编程变得简单且易于理解，并提高应用程序的性能和可伸缩性。

4. 三路比较运算符：C++20中引入了一个新的三路比较运算符（<=>），它可以比较两个对象，并返回一个“小于”，“等于”或“大于”的结果。这可以简化比较操作的编写，并提高代码的可读性。

5. 初始化列表的改进：C++20中改进了初始化列表（initializer_list）的支持，允许开发者使用聚合体（aggregate）的方式初始化类对象。这可以减少代码重复和提高代码的可读性。

6. 常量表达式的改进：C++20中引入了一些常量表达式的改进，使得程序员能够更容易地将代码转换为常量表达式。这可以提高代码的性能和可移植性。

# 3. 野指针出现的可能性

1. 指针未初始化：指针在声明时未被初始化，其值是不确定的。在使用该指针之前需要先将其初始化为一个有效的地址，否则可能会导致野指针。

2. 释放后未将指针置为NULL：当使用完动态分配的内存后，需要将指向该内存的指针置为NULL，防止后续误用。如果没有这样做，指针可能会继续指向已释放的内存，成为野指针。

3. 指针操作错误：在进行指针操作时，可能会出现一些错误，例如指针越界、错误类型转换等。这些错误可能会导致指针指向未知的内存地址，成为野指针。

4. 函数返回局部变量的地址：如果函数返回局部变量的指针，那么在函数结束时，该变量所占用的栈空间将被释放。这种情况下，返回的指针将指向已经被释放的内存，成为野指针。

5. 错误的内存管理：在手动管理内存时，如果不小心释放了正在使用的内存或没有正确地分配内存，可能会导致野指针。这种情况下需要注意内存的分配和释放。

# 4. 进程崩溃怎么排查

# 5. top线程所占资源怎么查看，查看一个文件n-m行 linux使用的版本号

# 6. 进程线程的区别，使用场景

# 7. 网络传输包的时候丢了200字节怎么排查检查网络连接：检查网络连接是否正常，网络设备是否能够正常工作，例如网线、路由器、交换机等是否正常连接，以及设备是否有异常报警信息。

检查网络拥堵：检查网络拥堵情况，可以使用 ping 命令或 traceroute 命令对网络进行探测，如果网络拥堵情况比较严重，建议增加网络带宽或者升级网络设备。

检查网络配置：检查网络配置是否正确，例如 IP 地址、子网掩码、网关等配置是否正确，是否存在 IP 地址冲突等问题。

检查防火墙：检查防火墙是否存在过滤丢包的规则，例如某些端口是否被防火墙过滤掉。

检查设备故障：检查网络设备是否存在故障，例如网卡是否工作正常，网络设备是否过热等问题。

# 8. 做个题目， 二分查找

# 9. 做项目最大的难点，讲两个

# 10. 挑个最深的特性讲一讲

[Notes on C++ SFINAE, Modern C++ and C++20 Concepts - C++ Stories (cppstories.com)](https://www.cppstories.com/2016/02/notes-on-c-sfinae/)

SFINAE

哪里使用：cppstories网站我希望你能对 SFINAE 有一个基本的了解，但我们在哪里可以使用这种技术呢？一般答案是：只要我们想为特定类型选择合适的函数/特化。保证编译器在泛型函数、偏特化、及一般重载函数中遴选函数原型的候选列表时不被打断。

其中一些例子是  

- 当 T 具有给定的方法时调用函数（如 T 具有 toString 方法时调用 toString()  

- 禁止从封装类型进行缩小或错误转换。例如，这用于防止 std::variant 推导出错误的类型。参见《C++17 中关于 std::variant 的所有须知--类型转换》。  

- 在 SO 中有一个很好的例子，可以检测在初始化列表中传递给构造函数的对象数量。  

- 为我们拥有的所有类型特质（is_integral、is_array、is_class、is_pointer 等......这里还有更多特质）专门设计一个函数。  

- 在 Foonathan 博客：有一个如何计算给定输入数字类型中的位数的示例。SFINAE 是解决方案的一部分（还有标签分派）  

- Foonathan 博客中的另一个示例--如何使用 SFINAE 和标签调度在原始内存空间中构造一系列对象。

通常与enable_if一起使用，而enable_if又用到了SFINAE

enable_if<condition, T>当条件为真的时候返回生成T，不然生成一个无效类型，致使匹配失败。

在C++14，17中可以使用带_v和_t的来简化书写。condition比如可以是is_void, is_arithmetic,还可以是判断有没有移动构造函数等判断。

## Why should I avoid std::enable_if in function signatures

https://stackoverflow.com/questions/14600201/why-should-i-avoid-stdenable-if-in-function-signatures

# 11.最新的C++有什么特性

[How to Use Monadic Operations for `std::optional` in C&#43;&#43;23 - C&#43;&#43; Stories](https://www.cppstories.com/2023/monadic-optional-ops-cpp23/)
