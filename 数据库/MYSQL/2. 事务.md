# MYSQL事务四大特性（ACID）

原子性：一个事物必须视为不可分割的最小执行单元。要么全成功要么全失败

一致性：数据库总是从一个一致状态到另一个一致状态

隔离性：一个事务的中间结果对其他事务是不可见的

持久性：事务一旦提交就会永久保存到数据库。

# 并发事务会出现什么问题？

- **脏读：** 读到了其他事物未提交的数据，未提交意味着这些数据可能回滚，最终不会存到数据库中，也就是不存在的数据。读到了不一定存在的就是脏读

- **不可重复读：** 在同一事务内，不同时刻读到的同一批数据可能是不一样的，可能会受到其他事物的影响，比如其他事物该改了这批数据并提交了。通常针对数据更新

- **幻读：** 针对数据插入。假设事务A对某些行的内容作了更改，但是还未提交，此时事务B插入了与事务A更改前的记录相同的记录行，并在A之前提交了，而这时A查询会发现刚刚的更改对于某些数据未起作用

# MYSQL的事务隔离级别？

- **读未提交：** 指一个事务还没提交时，他做的变更就能被其他事务看到

- **读提交：** 指一个事务提交之后，他做的变更才能被其他事务看到

- **可重复读：** 一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，**MYSQL InnoDB引擎的默认隔离级别**

- **串行化：** 会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突，后访问的事务必须等前一个事务执行完成，才能继续执行。

# 在不同事务隔离级别下会发生什么现象？

- **读未提交：** 可能发生脏读、不可重复读和幻读

- **读提交：** 可能发生不可重复读和幻读，但不可能发生脏读

- **可重复读：** 可能发生幻读

- **串行化：** 都不可能发生

# MVCC实现原理

![](C:\Users\ljc\Documents\GitHub\--\数据库\MYSQL\图片\MVCC.jpg)

Read View有四个重要字段：

- m_ids: 指的是在创建Read View时，当前数据库中活跃事务的事务id列表，活跃十五就是启动了但还没提交的事务

- min_trx_id: 指的是在创建Read View时，当前数据库中活跃事务中事务id最小的事务，也就是m_ids的最小值

- max_trx_id: 创建Read View时当前数据库中应该给下一个事务的id值，也就是全局事务中最大的事务id值+1.

- creator_trx_id: 指的是创建该Read View的事务的事务id

对于使用InnoDB存储引擎的数据库表，它的聚簇索引记录中都包含下面两个隐藏列：

- trx_id，当一个事务对某条局促索引记录进行改动时，就会把该事务的事务id记录在trx_id隐藏列里。

- roll_pointer，每次对某条局促索引记录进行改动时，九八九版本的记录写入到undo日志中，然后这个隐藏列是个指针，只想每一个旧版本记录，于是就可以通过它找到修改前的记录

# 幻读是怎么解决的？

**快照读：** MVCC解决幻读，在可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事物插入了一条数据，查询不出来这条数据。

**当前读：** 是通过next-ket lock 记录锁+间隙锁方式解决了幻读，如果有其他事务在next-key-lock锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入。

> 失效
> 
> - 对于快照读，MVCC并布恩那个完全避免幻读现象。当事务A更新了一条事务B插入的记录，那么事务A前后两次查询的记录条目就不一样了，所以就发生幻读。
> 
> - 对于当前读，如果事务开启后，并没有执行当前读，而是先快照读，然后这期间如果其他事务插入了一条记录，那么事务后续使用当前读进行查询的时候，就会发现两次查询的记录条目不一样了，所以就发生幻读。
> 
> 即MYSQL可重复读隔离级别并没有彻底解决幻读，只是很大程度上避免了幻读现象的发生。

# 读提交是怎么实现的？

读提交隔离级别是每次读取数据的时候，都生成一个新的Read View。事务期间的多次读取同一条数据，前后两次读的数据可能不一致，因为这期间另一个事务修改了该记录，并提交了事务。

# 背诵版--MYSQL怎么解决幻读的？

幻读是在事务的前后两次查询中，后一次看到了前一次没有看到的行。

后果就是，数据库中的数据和binlog中的不一致，其原因就是，我们无法阻止新插入的数据，在加行锁之后，新插入的行还不存在，所以没法阻止。那这个新插入的数据在主库中可能是这个样子从库执行完binlog之后其实是会被修改的。

幻读在当前读的情况下才会出现，读取的是最新版本的数据，并且对行进行加锁。

与之对应的是快照读，读的是快照中的数据，不需要加锁。读取已提交和可重复读这俩隔离级别下的普通select就是快照读。其实就是MVCC，或者说快照读下，使用MVCC解决幻读。

然后对于当前读这种情况，考虑再加一个间隙锁，把行之间的间隙也锁住。

间隙锁只在可重复读隔离级别下生效，也可以使用更高的可串行化隔离级别，杜绝幻读。
