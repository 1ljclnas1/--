# 概述

## 1. 第一，二，三范式

1NF 用来确保每列的原子性，要求每列不可再分

2NF 在1NF的基础上要求每列斗鱼主键相关，要求实体的唯一性
在2NF的基础上确保每列都和主键直接相关，即限制列的冗余性

## 2. varchar和char的区别

char最长255个字符 varchar 65535个

char自动用空格补全 （用于定长）varchar用于不定长

char查找效率高

## 3. join和left join的区别

join等价于inner join，时返回两个表中都有符合条件的行

left join是返回左表中所有的行以及右表中符合条件的行

right join是返回右表中所有的行以及左表中符合条件的行

## 4. SQL怎么实现模糊查询

索引B+树是按照索引值有序排列存储的，只能根据前缀进行比较。每一次按照模糊匹配的前缀字典序来进行比较。

## 5. select的执行过程

**连接**：首先客户端和MYSQL通过三次握手建立连接，MYSQL是基于TCP进行传输。MYSQL如果没有启动就会报错。正常运行的话就校验用户名密码，如果认证错误也报错。检验通过之后连接器会获取用户权限并保存起来，后续任何操作都会基于开始的读到权限进行判断，即便创建连接之后改了权限也不会影响已连接的权限。

**查询缓存** 连接成功后会像MYSQL发送SQL语句，MYSQL收到后解析，如果是SELECT就去缓存中查。缓存以K-V形式保存在内存中，key是SQL语句，value是SQL拆线呢结果。没有就继续向下执行

**SQL解析**：词法分析和语法分析，词法分析是识别出关键字，方便后续优化，语法分析根据语法规则看看是否满足要求，不对就报错

**执行SQL**：prepare预处理、optimize优化和execute执行阶段。预处理器检查SQL查询的表或者字段是否存在，如果有*就将它扩展为SQL的所有的列。优化器是确定SQL语句的执行方案，比如有索引会选择走了哪个索引。执行器会与存储引擎交互，如果走索引了就将相应索引条件交给存储引擎，存储引擎通过B+树定位数据，如果数据不存在就向执行器返回错误，然后查询结束，找到了就返回，执行器读到数据之后判断记录是否满足要求，如果满足要求就返回客户端，重复操作直至退出循环。如果使用联合索引，会在存储引擎层分别判断每个索引是否满足条件，不先执行回表，所有索引有一个不成立就跳过，否则就返回给Server层回表，这是一个索引下推的过程

## 6. update的执行过程

执行器负责具体执行，会调用存储引擎接口，通过主键索引树获取一行记录：

- 如果记录所在的数据页本来就在buffer pool中，就直接返回给执行器更新

- 如果记录不在buffer pool，就将数据页从磁盘读入到buffer pool，返回记录给执行器。

执行器得到聚簇索引记录后，会看一下更新前的记录和更新后的记录是否一样

- 如果一样就不进行后续更新流程

- 如果不一样就把更新前的记录和更新后的都当作参数传给InnoDB曾，让InnoDB真正执行更新操作

开启事务，都先要记录相应的undo log，需要把被更新的列的旧值记下来，undo log会写入Buffer Pool中的Undo页面，不过在内存修改该Undo页面后，需要记录对应的redo log

InnoDB层开始更新记录，会先更新内存（同时标记为脏页），然后将记录写到redo log里面，这个时候更新完成。为了减少磁盘IO，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘

在一条更新语句执行完成后，开始记录对应的binlog，此时记录的binlog会被保存到binlog cache，当事务提交时才会同意将该事务运行过程中的所有binlog刷新到硬盘

两阶段提交：

prepare阶段：将redo log对应的事务状态设置为prepare，然后将 redo log刷盘

commit阶段：将binlog刷盘，接着调用引擎的提交事务接口，将redo log状态设置为commit（将事务设置为commit状态后，刷入到磁盘redo log文件）

## 7. count性能比较

count(*) = count(1) > count(主键)>count(字段)

## 8. drop、truncate和delete的区别

drop删除整张表和表结构，以及表的索引、约束和触发器；truncate只删除表数据，表结构、索引、约束等被保留；delete只删除表的全部或部分数据，表结构、索引、约束被保留

delete是每次从表中删除一行，并同时将改行的删除操作作为事务记录在日志中保存以便进行回滚

truncate 和 drop不支持where条件

drop > truncate > delete

truncate实现复制表结构，然后把原来的表整体删除

truncate只能针对table

delete可以针对table和view

## 9. MYSQL会出现死锁么，怎么检测

如果update语句的where条件没有用到索引例，那么久全表扫描，在一行行扫描的过程中，不仅给行记录加上了行锁，还给行记录两边的空袭也加上了间隙锁，相当于锁住整个表，然后直到事务结束才会释放锁

行锁会发生死锁，表锁不会。死锁的四个必要条件：互斥，占有且等待，不可剥夺，循环等待。

解决办法：

- 设置事务等待锁的超时时间。当一个事务的等待时间超过阈值后，直接回滚，释放锁。I你弄DB中，参数innodb_lock_wait_timeout是用来设置的默认50s

- 开启主动死锁检测。死锁检测发现死锁后，主动回滚链条中的一个事务。innodb默认开启
