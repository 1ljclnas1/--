# C++

## 第八章 非静态数据成员默认初始化 C++11 C++ 20

C++ 11 以前非静态数据成员初始化需要用初始化列表，但是如果数据成员多，则构造函数不好写，因此C++11提出新的初始化方法：**声明非静态数据成员**的同时直接使用=或者{}初始化

```cpp
int a = 0;
int b{1};
```

由此，构造函数可以专注于特殊数据成员初始化。

**初始化优先级：初始化列表优先于声明时的默认初始化**

**注意：不能使用()对非静态数据成员进行初始化，不能使用auto声明和初始化非静态数据成员**

C++ 20对此特性又进行了扩充，可以对位域成员进行默认初始化

```cpp
struct S {
    int y : 8 = 11;
    int z :4 {7};
}
```

**注意：当表示位域的常量表达式是一个条件表达式的时候**

```cpp
int a;
struct S2{
    int y: true ? 8 : a = 42;
    int z : 1 || new int { 0 };
}    
```

**这段代码中并不存在默认初始化， 因为最大化识别标识符的解析规则让=42 和 {0}不可能存在于解析的顶层。于是上面的代码被解析为**

```cpp
int a;
struct S2{
    int y: (true ? 8 : a = 42);
    int z : (1 || new int { 0 });
}    
```

所以可以通过()来明确被解析的优先级

```cpp
int a;
struct S2{
    int y: (true ? 8 : a) = 42;
    int z : (1 || new int) { 0 };
}    
```

## 总结

非静态数据成员默认初始化一定程度解决了代码冗余问题，可读性更强初始化方法更简单直接。

## 第九章 列表初始化 C++11 C++20

使用括号初始化的方式是直接初始化。等于号是拷贝初始化，调用的依然是直接初始化对应的构造函数，只不过是隐式调用。如果将C (int a) 声明为explicit那么等号就会失败 C x2 = 4。new运算符和类构造函数的初始化列表就是直接初始化。而函数传参和return返回的是拷贝初始化。

使用大括号初始化是列表初始化，同样区分直接初始化和拷贝初始化。

```cpp
int x = {5};        // 拷贝初始化
int x1{8};          // 直接初始化
C X2 = {4}          // 拷贝初始化
C X3{2};            // 直接初始化
foo({8});           // 拷贝初始化
foo({"hello", 8});  // 拷贝初始化
C x4 = bar();       // 拷贝初始化
C *x5 = new C({"hi", 42}); // 直接初始化
```

支持隐式调用多参数的构造函数

STL容器之所以支持列表初始化，不仅是因为编译器支持，同时也是它们支持std::initializer_list为形参的构造函数。std::initializer_list是一个支持begin、end以及size成员函数的类模板。编译器负责将列表里的元素构造为initializer_list的对象，然后寻找标准容器中支持它的构造函数并调用它。

**注意：std::initializer_list的begin、end并不返回一个迭代器对象，而是一个常量对象指针 const T***

### 使用列表初始化的注意事项

#### 隐式缩窄转换问题

它是编写代码中稍不留意出现的，不一定引发错误，甚至可能没有警告

```cpp
int x = 12345;
char y = x;
```

如果使用列表初始化就可以避免这类现象，

```cpp
int x{12345};
char y{x};
```

MSVC和Clang就不会编译通过

哪些是隐式缩窄转换

- 从浮点类型转换为整数类型

- 从long double 转换为double或float，或从double转换为float。

- 从整数类型或非强枚举类型转换到浮点类型，除非转换源是常量表达式。

- 从整数类型或非强枚举类型转换到不能代表所有原始类型值的整数类型，除非源是一个常量表达式，其值在转换之后能够使和目标类型。

如果一个类同时拥有满足列表初始化的构造函数，且其中一个是以std::initializer_list为参数，那么优先这个。

### 指定初始化

为了提高数据成员初始化的可读性和灵活性，C++20引入指定初始化。

```cpp
struct Point {
    int x;
    int y;
}
Point p{ .x = 4, .y = 2};
```

**注意**

- 指定初始化要求对象必须是一个聚合类型即只有数据成员，

- 指定的数据成员必须是非静态数据成员，因为静态成员不属于某个对象。

- 每个非静态数据成员只能初始化一次。

- 非静态数据成员的初始化必须按照顺序初始化。

- 针对联合体的数据成员只能初始化一次，不能同时指定。

- 不能嵌套指定初始化，但是如果确实想嵌套初始化可以通过另一种方式。

- 在C++20中一旦使用嵌套初始化，就不能混用其他方法对数据成员进行初始化

- 指定初始化不能初始化数组

```cpp
struct Point3D{
    Point3D(){}
    int x;
    int y;
    int z;
}
```

上面这个就不是因为它有构造函数，可以使用直接初始化赋默认值。

```cpp
嵌套初始化
struct Line {
    Point a;
    Point b;
}
Line1 { .a {.y = 5} }
```

```cpp
指定初始化在c++中无法初始化数组，但是在C语言中可以，而拒绝的理由是与lambda表达法冲突了
int arr[3] = { [1] = 5 };
```

### 总结

它解决了容器初始化复杂的问题，使自定义容器支持列表初始化变得容易。C++20引入指定初始化一定程度简化了复杂聚合类型初始化工作，让初始化复杂聚合类型的代码变得容易。

## 第十章 默认和删除函数 C++11
