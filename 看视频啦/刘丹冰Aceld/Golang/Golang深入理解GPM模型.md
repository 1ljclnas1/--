# 调度器的由来

内核线程绑定协程调度器，协程调度器绑定很多个协程。这样CPU本身就不需要切换了， 但是就有一个协程阻塞的问题会阻塞后续的协程执行。

改成多个线程绑定协程调度器，协程调度器绑定多个协程变成了M比N的关系

# Goroutine调度器的GMP模型的设计思想

## 1. GMP模型简介

G ：goroutine协程

P：processor处理器

M：thread线程

![](C:\Users\ljc\Documents\GitHub\--\看视频啦\刘丹冰Aceld\图片\GMP.PNG)

全局队列：存放等待运行的G

P的本地队列：当前P即将要执行的G（有数量限制，一般不超过256个G）新建的会优先放入某个P的本地队列，如果不能才会放在全局队列中

P列表：有多少个P，通过GOMAXPROCS配置（runtime.GOMAXPROCS()设置），程序启动时配置

M列表：当前操作系统分配到Go程序的内核线程数，M的数量与P无关，Go语言本身是限定M的最大量是10000（忽略）。可以通过runtime/debug包中的SetMaxThreads函数设置。一般不这么用，因为M是动态地，一旦一个M阻塞就会创建一个M，如果有M空闲，就会回收或者睡眠。

## 2. 调度器的设计策略

复用线程，利用并行，抢占，全局G队列

### 复用线程：

- work stealing机制：当一个P的本地队列为空的时候，如果全局也是空的，就会去另一个P的本地队列里去偷取一些G，一般偷取一半，去比较繁忙的P里面偷取。优先考虑偷取，而不是睡眠。

- ![](C:\Users\ljc\Documents\GitHub\--\看视频啦\刘丹冰Aceld\图片\work%20stealing.PNG)

- hand off 机制：一旦G1协程阻塞，很显然，要尝试或者唤醒一个新的M，把P1迁移到新的M3上，然后M1继续运行G1![](C:\Users\ljc\Documents\GitHub\--\看视频啦\刘丹冰Aceld\图片\hand%20off.PNG)

### 利用并行

GPMAXPROCS

### 抢占

每个G最多10ms，超过下一个G就抢占

### 全局G队列

对work stealing机制做一个补充，本地空了去全局拿。

补充：本地队列->全局队列->netpoll->其他队列 从其他队列偷是不加锁的，先确定要切取得数量，执行复制再进行删除。

## 3. go func() 经历了什么过程

创建G放入局部队列，局部队列满就放入全局队列。M通过P获取G，如果P为空就从全局获取，如果全局为空就从其他的MP组合偷取，然后进行调度执行，时间片超时后返回绑定的P的队列，G在执行的时候如果阻塞了，就会尝试从已经休眠的M队列里或者创建一个新的M线程，尝试接管因G阻塞被阻塞的P，如果G阻塞结束后，M1要么销毁要么回到休眠队列，然后G回到某一个P里面或者回到全局队列。

## 4. 调度器的生命周期

M0和G0

M0：启动程序（进程）后编号为0的主线程，在全局变量runtime.m0中，不需要在heap上分配，负责执行初始化操作和启动第一个G，启动第一个G之后，M0就和其他的M一样了

G0：每次启动一个M，都会第一个创建的goroutine，就是G0，G0仅用于负责调度的G，G0不指向任何可执行的函数，每个M都会有一个自己的G0，在调度或系统调用时会使用M会切换到G0来调度。

## 5. 可视化的GMP编程

基本的trace编程

- 创建trace文件

- 启动trace

- 停止trace

- 通过go tool trace工具打开文件
