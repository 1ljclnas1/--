# 三色标记法

三色的流程就不写了.....

如果不使用STW，会发生一些事情，如果这个事情同时满足以下两个条件，就会出现问题：

1. 一个白色对象被黑色对象引用

2. 灰色对象与它之间的可达关系的白色对象遭到破坏

我们需要做的是破坏两个条件同时成立

因此google研究了强三色不变式和弱三色不变式

**强三色不变式：** 强制性不允许黑色对象引用白色对象   破坏条件一

**弱三色不变式：** 当灰色或者白色对象删除一个对白色对象的引用的时候，保证其上游有灰色节点。   破坏条件二

# 屏障机制

一个额外的判断，遏制条件一和二的发生

## 插入屏障

对象被引用的时候触发（不在栈上使用）

**具体操作：** 在A对象引用B对象的时候，B对象被标记为灰色。（将B挂在A下游）

**满足：** 强三色不变式（破坏了条件一）

因为栈不用这个机制，所以还是需要STW（尽管极大的减少了STW时间），重新扫描栈

**不足：** 需要STW扫描栈

## 删除屏障

对象被删除的时候触发

**具体操作：** 被删除对象，如果自身为灰色或白色，就被标记为灰色

**满足：** 弱三色不变式 （保护灰色到白色的路径不断）

对于应该在这一轮删除的对象，延迟一轮删除。

**不足：** 回收精度低，延迟删除。

## 混合写屏障

**具体操作：** 

1. GC开始，将栈上的可达对象全部标记为黑色

2. GC期间，任何在栈上创建的新对象，均为黑色（不用第二次扫描）

3. 被删除的对象被标记为灰色（删除写屏障）

4. 被添加的对象被标记为灰色

栈不启用屏障，堆启用屏障

**满足：** 变形的弱三色不变式（防止白色节点丢失）
